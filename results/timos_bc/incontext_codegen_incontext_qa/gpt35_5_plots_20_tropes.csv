result|answer|code|id|query|img_path|possible_answers
no|no|"def execute_command_tt0071129_0(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Big Bad
    # Definition: The character who is the direct cause of all of the bad happenings in a story.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Big Bad"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Big Bad"" usually involves a character who is the primary antagonist or the main source of conflict in the story
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the primary antagonist
        if frame.exists(""primary antagonist""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist action
            antagonist_action = frame.find(""primary antagonist"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of primary antagonist in {i} th frame""] = antagonist_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_0|"Is the trope ""Big Bad"", which means ""The character who is the direct cause of all of the bad happenings in a story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_3(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Smug Snake
    # Definition: A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Smug Snake"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Smug Snake"" usually involves a character with specific behavioral traits, such as disdainful expressions, body language, or interactions with others
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""villain""):
            # Query the villain's behavior
            villain_behavior = frame.find(""villain"")[0].simple_query(""How is the villain behaving?"")
            # Append infomation of frame to info dictionary
            info[f""Villain's behavior in {i} th frame""] = villain_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_3|"Is the trope ""Smug Snake"", which means ""A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_5(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Would Hurt a Child
    # Definition: People that do hurt children, sometimes even kill them.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Would Hurt a Child"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Would Hurt a Child"" usually involves two characters like antagonist and child
    # 3. Action Analysis: For frames antagonist and child both present, the action like ""antagonist attacking"" or ""child is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and child
        if frame.exists(""antagonist"") and frame.exists(""child""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / child action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            child_action = frame.find(""child"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of child
            child_emotion = frame.simple_query(""What emotion does child have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of child in {i} th frame""] = child_action
            info[f""Child emotion in {i} th frame""] = child_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_5|"Is the trope ""Would Hurt a Child"", which means ""People that do hurt children, sometimes even kill them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_9(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Deadpan Snarker
    # Definition: A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Deadpan Snarker"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Deadpan Snarker"" usually involves a character who is prone to making sarcastic or witty remarks. We need to detect the presence of such a character and their actions.
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character prone to making sarcastic or witty remarks
        if frame.exists(""sarcastic character""):
            # Query the character's behavior
            character_behavior = frame.find(""sarcastic character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Behavior of sarcastic character in {i} th frame""] = character_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_9|"Is the trope ""Deadpan Snarker"", which means ""A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_10(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Determinator
    # Definition: A character, good or evil, male or female, young or old, who never gives up. Ever. No matter what.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Determinator"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Determinator"" usually involves a single character who is persistently fighting or struggling against all odds
    # 3. Action Analysis: For frames where the character is present, analyze the character's actions and the context to determine if they align with the trope definition
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the main character
        if frame.exists(""main character""):
            # Query the main character's action
            character_action = frame.find(""main character"")[0].simple_query(""What is he/she doing?"")
            # Query the context
            context_query = frame.simple_query(""What is happening around the character?"")
            # Append infomation of frame to info dictionary
            info[f""Action of main character in {i} th frame""] = character_action
            info[f""Context in {i} th frame""] = context_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_10|"Is the trope ""Determinator"", which means ""A character \ good or evil, male or female, young or old \ who never gives up. Ever. No matter what."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|yes|"def execute_command_tt0071129_11(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Only Sane Man
    # Definition: When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only one who, well, isn't.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Only Sane Man"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Only Sane Man"" usually involves a group of characters, and one character who is the only sane person
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the group of characters and the only sane man
        if frame.exists(""group_of_characters"") and frame.exists(""only_sane_man""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the behavior of the group of characters and the only sane man
            group_behavior = frame.find(""group_of_characters"")[0].simple_query(""What are they doing?"")
            sane_man_behavior = frame.find(""only_sane_man"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Behavior of group of characters in {i} th frame""] = group_behavior
            info[f""Behavior of the only sane man in {i} th frame""] = sane_man_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_11|"Is the trope ""Only Sane Man"", which means ""When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only 
one who, well, isn't."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
yes|no|"def execute_command_tt0071129_17(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Too Dumb to Live
    # Definition: People who are so stupid that they simply do not deserve to survive.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Too Dumb to Live"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Too Dumb to Live"" usually involves a character making a series of poor decisions or being oblivious to danger
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query character's decision-making
            decision_making = frame.find(""character"")[0].simple_query(""What is the character doing?"")
            # Query character's awareness of danger
            danger_awareness = frame.find(""character"")[0].simple_query(""Is the character aware of the danger?"")
            # Append infomation of frame to info dictionary
            info[f""Decision-making of character in {i} th frame""] = decision_making
            info[f""Danger awareness of character in {i} th frame""] = danger_awareness
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_17|"Is the trope ""Too Dumb to Live"", which means ""People who are so stupid that they simply do not deserve to survive."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_20(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adorkable
    # Definition: An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character an endearing vulnerability.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adorkable"" character might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adorkable"" character usually involves a character with socially inept, shy or clumsy behavior
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify adorkable character
        if frame.exists(""adorkable_character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query adorkable character's behavior
            behavior = frame.find(""adorkable_character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Behavior of adorkable character in {i} th frame""] = behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_20|"Is the trope ""Adorkable"", which means ""An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character 
an endearing vulnerability."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_28(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adult Fear
    # Definition: Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adult Fear"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adult Fear"" usually involves scenarios that mature, well-adjusted adults are concerned about. This could involve detecting specific objects, settings, or facial expressions associated with adult fears
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Detect visual cues of adult fears
        adult_fear_query = frame.simple_query(""Is there anything that mature, well-adjusted adults are concerned about?"")
        if ""yes"" in adult_fear_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there anything that mature, well-adjusted adults are concerned about?"")
            info[f""Caption of {i} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_28|"Is the trope ""Adult Fear"", which means ""Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_29(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Not So Different
    # Definition: When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more than the other character would want to believe.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Not So Different"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Not So Different"" usually involves two characters, so we need to detect the presence of two characters and their interactions
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the two characters
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the interaction between the two characters
            interaction_query = frame.simple_query(""What is the interaction between character1 and character2?"")
            # Append infomation of frame to info dictionary
            info[f""Interaction in {i} th frame""] = interaction_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_29|"Is the trope ""Not So Different"", which means ""When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more 
than the other character would want to believe."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
yes|no|"def execute_command_tt0071129_32(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Eye Scream
    # Definition: When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the invasion of the eye sockets by a foreign body.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Eye Scream"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Eye Scream"" usually involves a character's face and a foreign object near the eyes
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify character's face and foreign object near the eyes
        if frame.exists(""character's face"") and frame.exists(""foreign object near the eyes""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the presence of invasion of the eye sockets by a foreign body
            invasion_query = frame.simple_query(""Is there invasion of the eye sockets by a foreign body?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Invasion of the eye sockets by a foreign body in {i} th frame""] = invasion_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_32|"Is the trope ""Eye Scream"", which means ""When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the 
invasion of the eye sockets by a foreign body."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_46(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Screw This, I'm Outta Here!
    # Definition: a character decides to leave, quit, or abandon a situation, often in a dramatic or humorous fashion
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Screw This, I'm Outta Here!"" can happen at any point in the video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Look for a character showing signs of frustration, anger, or determination to leave
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query the character's emotion and action
            character_emotion = frame.find(""character"")[0].simple_query(""What emotion does the character have?"")
            character_action = frame.find(""character"")[0].simple_query(""What is the character doing?"")
            # Append infomation of frame to info dictionary
            info[f""Emotion of character in {i} th frame""] = character_emotion
            info[f""Action of character in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_46|"Is the trope ""Screw This, I'm Outta Here!"", which means ""Screw you guys, I'm going home."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_47(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Kick the Dog
    # Definition: an act of cruelty by a character, typically towards a more vulnerable or defenseless entity, to establish the character's malevolence
    # Thought: we devide the trope detection into 4 steps
    # 1. Frame Selection: Since ""Kick the Dog"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Kick the Dog"" usually involves two characters like antagonist and victim(for example animal, child or visibly weakly character)
    # 3. Action Analysis: For frames antagonist and victim both present, the action like ""antagonist attacking"" or ""victim is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and victim
        if frame.exists(""antagonist"") and frame.exists(""victim""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / victim action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            victim_action = frame.find(""victim"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of victim`    
            victim_emotion = frame.simple_query(""What emotion does victim have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of victim in {i} th frame""] = victim_action
            info[f""Victim emotion in {i} th frame""] = victim_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_47|"Is the trope ""Kick the Dog"", which means ""When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift 
audience sympathy away from him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_62(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Blatant Lies
    # Definition: A glaringly obvious lie.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: Since ""Blatant Lies"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Blatant Lies"" usually involves characters, especially the one who is lying
    # 3. Action Analysis: For frames where the character is present, analyze the character's facial expressions, body language, and the context of the scene to detect signs of lying
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters
        if frame.exists(""character""):
            # Query the character's facial expression and body language
            facial_expression = frame.find(""character"")[0].simple_query(""What is the character's facial expression?"")
            body_language = frame.find(""character"")[0].simple_query(""What is the character's body language?"")
            # Append infomation of frame to info dictionary
            info[f""Facial expression of character in {i} th frame""] = facial_expression
            info[f""Body language of character in {i} th frame""] = body_language
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_62|"Is the trope ""Blatant Lies"", which means ""A glaringly obvious lie."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_71(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Irony
    # Definition: The intended meaning is an inversion of the plain meaning.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Irony"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Irony"" usually involves two characters or objects, one of which is expected to behave or appear in a certain way, but does the opposite
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters or objects
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the actions or behaviors of the characters or objects
            character1_action = frame.find(""character1"")[0].simple_query(""What is he/she doing?"")
            character2_action = frame.find(""character2"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Action of character1 in {i} th frame""] = character1_action
            info[f""Action of character2 in {i} th frame""] = character2_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_71|"Is the trope ""Irony"", which means ""The intended meaning is an inversion of the plain meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
yes|no|"def execute_command_tt0071129_73(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Stealth Pun
    # Definition: The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Stealth Pun"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Detect objects or characters that are likely to be involved in a pun or joke
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters and objects
        if frame.exists(""character"") and frame.exists(""object""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query for pun or joke
            pun_query = frame.simple_query(""Is there a pun or joke present?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Pun or joke in {i} th frame""] = pun_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_73|"Is the trope ""Stealth Pun"", which means ""The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_74(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Bittersweet Ending
    # Definition: When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some irrevocable loss has happened during the course of the events, and nothing will ever be the same again.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: ""Bittersweet Ending"" refers to an ending, so we only analyze the final part of video segment
    # 2. Detection of emotional and contextual cues: Analyze the frames for visual cues of bittersweetness, such as mixed emotions, irrevocable loss, or significant change
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    for i, frame in enumerate(ending_segment.frame_iterator()):
        # Detect visual cues of bittersweetness
        mixed_emotions_query = frame.simple_query(""Are there mixed emotions?"")
        irrevocable_loss_query = frame.simple_query(""Is there irrevocable loss or significant change?"")
        if ""yes"" in mixed_emotions_query or ""yes"" in irrevocable_loss_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there any mixed emotions or irrevocable loss present in the frame?"")
            info[f""Caption of {ending_segment.start + 1} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_74|"Is the trope ""Bittersweet Ending"", which means ""When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some 
irrevocable loss has happened during the course of the events, and nothing will ever be the same again."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_82(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: What the Hell, Hero?
    # Definition: When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""What the Hell, Hero?"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""What the Hell, Hero?"" usually involves two characters like hero and other character calling out the hero
    # 3. Action Analysis: For frames hero and other character both present, the action like ""other character calling out the hero"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify hero and other character
        if frame.exists(""hero"") and frame.exists(""other character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query hero / other character action
            hero_action = frame.find(""hero"")[0].simple_query(""What is he/she doing?"")
            other_character_action = frame.find(""other character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of hero in {i} th frame""] = hero_action
            info[f""Action of other character in {i} th frame""] = other_character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_82|"Is the trope ""What the Hell, Hero?"", which means ""When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_89(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Chekhov's Gunman
    # Definition: Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Chekhov's Gunman"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Chekhov's Gunman"" usually involves a character who seems unimportant at first but later becomes significant. We need to detect the presence of such characters and their actions.
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify unimportant characters
        if frame.exists(""unimportant_character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the action of the unimportant character
            character_action = frame.find(""unimportant_character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of unimportant character in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_89|"Is the trope ""Chekhov's Gunman"", which means ""Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|no|"def execute_command_tt0071129_90(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Red Herring
    # Definition: A clue or piece of information that is intended to be misleading, or distracting from the actual issue.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Red Herring"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Red Herring"" usually involves a misleading clue or piece of information, so we need to detect objects or context that could be misleading
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify misleading objects or context
        misleading_objects = frame.find(""misleading_object"")
        misleading_context = frame.simple_query(""Is there any misleading context?"")
        # Append infomation of frame to info dictionary
        info[f""Misleading objects in {i} th frame""] = misleading_objects
        info[f""Misleading context in {i} th frame""] = misleading_context
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0071129_90|"Is the trope ""Red Herring"", which means ""A clue that leads in the wrong direction."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0071129.mp4|['yes', 'no']
no|yes|"def execute_command_tt1623205_0(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Big Bad
    # Definition: The character who is the direct cause of all of the bad happenings in a story.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Big Bad"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Big Bad"" usually involves a single character who is the primary antagonist or the main source of conflict
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the primary antagonist
        if frame.exists(""antagonist""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_0|"Is the trope ""Big Bad"", which means ""The character who is the direct cause of all of the bad happenings in a story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|yes|"def execute_command_tt1623205_3(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Smug Snake
    # Definition: A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Smug Snake"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Smug Snake"" usually involves a character with specific behavioral traits like disdainful expressions, body language, and interactions with others
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the ""Smug Snake"" character
        if frame.exists(""Smug Snake""):
            # Query the character's behavior
            behavior_query = frame.find(""Smug Snake"")[0].simple_query(""How is the character behaving?"")
            # Query the character's interaction with others
            interaction_query = frame.find(""Smug Snake"")[0].simple_query(""How is the character interacting with others?"")
            # Append infomation of frame to info dictionary
            info[f""Behavior of Smug Snake in {i} th frame""] = behavior_query
            info[f""Interaction of Smug Snake in {i} th frame""] = interaction_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_3|"Is the trope ""Smug Snake"", which means ""A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_5(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Would Hurt a Child
    # Definition: People that do hurt children, sometimes even kill them.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Would Hurt a Child"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Would Hurt a Child"" usually involves two characters like antagonist and child
    # 3. Action Analysis: For frames antagonist and child both present, the action like ""antagonist attacking"" or ""child is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and child
        if frame.exists(""antagonist"") and frame.exists(""child""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / child action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            child_action = frame.find(""child"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of child
            child_emotion = frame.simple_query(""What emotion does child have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of child in {i} th frame""] = child_action
            info[f""Child emotion in {i} th frame""] = child_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_5|"Is the trope ""Would Hurt a Child"", which means ""People that do hurt children, sometimes even kill them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|yes|"def execute_command_tt1623205_9(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Deadpan Snarker
    # Definition: A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Deadpan Snarker"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Detect the presence of characters who are known for their sarcastic or witty remarks
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters
        if frame.exists(""sarcastic character"") or frame.exists(""witty character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query character's dialogues
            character_dialogue = frame.find(""sarcastic character"")[0].simple_query(""What is he/she saying?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Dialogue of character in {i} th frame""] = character_dialogue
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_9|"Is the trope ""Deadpan Snarker"", which means ""A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
yes|no|"def execute_command_tt1623205_10(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Determinator
    # Definition: A character, good or evil, male or female, young or old, who never gives up. Ever. No matter what.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Determinator"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Character Analysis: ""Determinator"" is a character trope, so we need to identify the character(s) that exhibit this trait. This could involve detecting specific actions, facial expressions, or dialogue that indicate unwavering determination
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the main character
        if frame.exists(""main character""):
            # Query the main character's determination
            determination_query = frame.find(""main character"")[0].simple_query(""Is the main character showing determination?"")
            # Append infomation of frame to info dictionary
            info[f""Determination of main character in {i} th frame""] = determination_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_10|"Is the trope ""Determinator"", which means ""A character \ good or evil, male or female, young or old \ who never gives up. Ever. No matter what."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_11(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Only Sane Man
    # Definition: When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only one who, well, isn't.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Only Sane Man"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Only Sane Man"" usually involves a group of characters, and the ""Only Sane Man"" character is expected to exhibit different behavior or reactions compared to the others
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the group of characters and the Only Sane Man
        if frame.exists(""group_of_characters"") and frame.exists(""Only Sane Man""):
            # Query the behavior of the Only Sane Man
            sane_man_behavior = frame.find(""Only Sane Man"")[0].simple_query(""What is the Only Sane Man doing?"")
            # Append infomation of frame to info dictionary
            info[f""Behavior of the Only Sane Man in {i} th frame""] = sane_man_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_11|"Is the trope ""Only Sane Man"", which means ""When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only 
one who, well, isn't."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_17(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Too Dumb to Live
    # Definition: People who are so stupid that they simply do not deserve to survive.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Too Dumb to Live"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Too Dumb to Live"" usually involves a character or characters making decisions that are obviously dangerous or foolish
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character or characters
        if frame.exists(""character""):
            # Query the character's decision-making
            decision_making = frame.find(""character"")[0].simple_query(""What decision is the character making?"")
            # Append infomation of frame to info dictionary
            info[f""Decision-making of character in {i} th frame""] = decision_making
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_17|"Is the trope ""Too Dumb to Live"", which means ""People who are so stupid that they simply do not deserve to survive."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
yes|no|"def execute_command_tt1623205_20(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adorkable
    # Definition: An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character an endearing vulnerability.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adorkable"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adorkable"" usually involves a character with socially inept, shy or clumsy behavior
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify adorkable character
        if frame.exists(""adorkable_character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query adorkable character's behavior
            adorkable_behavior = frame.find(""adorkable_character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Adorkable behavior in {i} th frame""] = adorkable_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_20|"Is the trope ""Adorkable"", which means ""An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character 
an endearing vulnerability."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_28(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adult Fear
    # Definition: Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adult Fear"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adult Fear"" usually involves scenarios that mature, well-adjusted adults are concerned about. This could involve detecting specific objects, settings, or facial expressions associated with adult concerns
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Detect visual cues of adult concerns
        adult_concerns_query = frame.simple_query(""Are there any adult concerns present?"")
        if ""yes"" in adult_concerns_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Are there any adult concerns present in the frame?"")
            info[f""Caption of {i} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_28|"Is the trope ""Adult Fear"", which means ""Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_29(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Not So Different
    # Definition: When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more than the other character would want to believe.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Not So Different"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Not So Different"" usually involves two characters, so we need to detect the presence of two characters and their interactions
    # 3. Contextual Analysis: For frames with both characters present, we analyze their actions, dialogues, and emotions to detect similarities or commonalities
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the two characters
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the interaction between the two characters
            interaction_query = frame.simple_query(""What is the interaction between character1 and character2?"")
            # Query the emotions of the characters
            character1_emotion = frame.find(""character1"")[0].simple_query(""What emotion does character1 have?"")
            character2_emotion = frame.find(""character2"")[0].simple_query(""What emotion does character2 have?"")
            # Append infomation of frame to info dictionary
            info[f""Interaction in {i} th frame""] = interaction_query
            info[f""Emotion of character1 in {i} th frame""] = character1_emotion
            info[f""Emotion of character2 in {i} th frame""] = character2_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_29|"Is the trope ""Not So Different"", which means ""When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more 
than the other character would want to believe."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
yes|no|"def execute_command_tt1623205_32(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Eye Scream
    # Definition: When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the invasion of the eye sockets by a foreign body.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Eye Scream"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Eye Scream"" usually involves a character's face and a foreign object near the eyes
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify character's face and foreign object near the eyes
        if frame.exists(""character's face"") and frame.exists(""foreign object near the eyes""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the presence of invasion of the eye sockets by a foreign body
            invasion_query = frame.simple_query(""Is there invasion of the eye sockets by a foreign body?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Invasion of the eye sockets by a foreign body in {i} th frame""] = invasion_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_32|"Is the trope ""Eye Scream"", which means ""When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the 
invasion of the eye sockets by a foreign body."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|yes|"def execute_command_tt1623205_46(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Screw This, I'm Outta Here!
    # Definition: a character decides to leave a situation, often in a dramatic or humorous fashion, to express frustration, annoyance, or a desire to disengage from a conflict or problem
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Screw This, I'm Outta Here!"" can happen at any point in the movie, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Look for visual cues of a character expressing frustration or annoyance, and possibly leaving a scene
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character and their action
        if frame.exists(""character""):
            # Query the character's action
            character_action = frame.find(""character"")[0].simple_query(""What is he/she doing?"")
            # Query the character's emotion
            character_emotion = frame.find(""character"")[0].simple_query(""What emotion does he/she have?"")
            # Append infomation of frame to info dictionary
            info[f""Action of character in {i} th frame""] = character_action
            info[f""Emotion of character in {i} th frame""] = character_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_46|"Is the trope ""Screw This, I'm Outta Here!"", which means ""Screw you guys, I'm going home."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
yes|no|"def execute_command_tt1623205_47(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Kick the Dog
    # Definition: an act of cruelty by a character, typically towards a more vulnerable or defenseless entity, to establish the character's malevolence
    # Thought: we devide the trope detection into 4 steps
    # 1. Frame Selection: Since ""Kick the Dog"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Kick the Dog"" usually involves two characters like antagonist and victim(for example animal, child or visibly weakly character)
    # 3. Action Analysis: For frames antagonist and victim both present, the action like ""antagonist attacking"" or ""victim is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and victim
        if frame.exists(""antagonist"") and frame.exists(""victim""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / victim action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            victim_action = frame.find(""victim"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of victim`    
            victim_emotion = frame.simple_query(""What emotion does victim have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of victim in {i} th frame""] = victim_action
            info[f""Victim emotion in {i} th frame""] = victim_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_47|"Is the trope ""Kick the Dog"", which means ""When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift 
audience sympathy away from him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_62(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Blatant Lies
    # Definition: A glaringly obvious lie.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Blatant Lies"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Blatant Lies"" usually involves characters, especially the one who is lying
    # 3. Action Analysis: For frames where the character is present, we analyze the character's facial expressions, body language, and the context of the scene to detect signs of lying
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters
        if frame.exists(""character""):
            # Query character's facial expression and body language
            facial_expression = frame.find(""character"")[0].simple_query(""What is the character's facial expression?"")
            body_language = frame.find(""character"")[0].simple_query(""What is the character's body language?"")
            # Append infomation of frame to info dictionary
            info[f""Facial expression of character in {i} th frame""] = facial_expression
            info[f""Body language of character in {i} th frame""] = body_language
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_62|"Is the trope ""Blatant Lies"", which means ""A glaringly obvious lie."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
yes|no|"def execute_command_tt1623205_71(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Irony
    # Definition: The intended meaning is an inversion of the plain meaning.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Irony"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Context Analysis: Analyze the frames for visual cues or dialogues that suggest an inversion of the plain meaning, such as characters saying one thing but meaning another, or situations that are contrary to expectations
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify dialogues and visual cues
        dialogue = frame.simple_query(""What are the characters saying?"")
        visual_cues = frame.simple_query(""Are there any visual cues of irony?"")
        # Append infomation of frame to info dictionary
        info[f""Dialogue in {i} th frame""] = dialogue
        info[f""Visual cues in {i} th frame""] = visual_cues
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_71|"Is the trope ""Irony"", which means ""The intended meaning is an inversion of the plain meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_73(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Stealth Pun
    # Definition: The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Stealth Pun"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Detecting puns: Look for visual or auditory cues that might indicate the presence of a pun, such as wordplay, visual gags, or double entendres
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Detect visual or auditory cues that might indicate the presence of a pun
        pun_query = frame.simple_query(""Is there any pun or wordplay present?"")
        if ""yes"" in pun_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there any pun or wordplay present in the frame?"")
            info[f""Caption of {i} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_73|"Is the trope ""Stealth Pun"", which means ""The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_74(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Bittersweet Ending
    # Definition: When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some irrevocable loss has happened during the course of the events, and nothing will ever be the same again.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: ""Bittersweet Ending"" refers to an ending, so we only analyze the final part of video segment
    # 2. Detection of emotional and contextual cues: Analyze the frames for visual cues of bittersweetness, such as mixed emotions, irrevocable loss, or significant change
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    for i, frame in enumerate(ending_segment.frame_iterator()):
        # Detect visual cues of bittersweetness
        mixed_emotions_query = frame.simple_query(""Are there mixed emotions?"")
        irrevocable_loss_query = frame.simple_query(""Is there irrevocable loss or significant change?"")
        if ""yes"" in mixed_emotions_query or ""yes"" in irrevocable_loss_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there any bittersweetness present in the frame?"")
            info[f""Caption of {ending_segment.start + 1} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_74|"Is the trope ""Bittersweet Ending"", which means ""When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some 
irrevocable loss has happened during the course of the events, and nothing will ever be the same again."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_82(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: What the Hell, Hero?
    # Definition: When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""What the Hell, Hero?"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""What the Hell, Hero?"" usually involves two characters like protagonist and other character calling out the protagonist
    # 3. Action Analysis: For frames protagonist and other character both present, the action like ""other character calling out the protagonist"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify protagonist and other character
        if frame.exists(""protagonist"") and frame.exists(""other character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query protagonist / other character action
            protagonist_action = frame.find(""protagonist"")[0].simple_query(""What is he/she doing?"")
            other_character_action = frame.find(""other character"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of other character`    
            other_character_emotion = frame.simple_query(""What emotion does other character have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of protagonist in {i} th frame""] = protagonist_action
            info[f""Action of other character in {i} th frame""] = other_character_action
            info[f""Other character emotion in {i} th frame""] = other_character_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_82|"Is the trope ""What the Hell, Hero?"", which means ""When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1623205_89(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Chekhov's Gunman
    # Definition: Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode.
    # Thought: we devide the trope detection into 3 steps
    # 1. Character Identification: Identify characters that are introduced early in the video and seem unimportant at first
    # 2. Character Relevance: Analyze the actions and interactions of these characters to determine if they become important later in the video
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the first 10% of the video is a reasonable segment to analyze for character introduction
    intro_segment_end = int(video_segment.num_frames * 0.1)
    intro_segment = video_segment.trim(end=intro_segment_end)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    # Identify characters introduced early in the video
    characters = [""character1"", ""character2"", ""character3""]  # Assuming we have a way to identify characters
    for character in characters:
        # Check if the character is present in the introduction segment
        is_present = intro_segment.frame_from_index(0).exists(character)
        info[f""{character} introduced""] = ""yes"" if is_present else ""no""
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_89|"Is the trope ""Chekhov's Gunman"", which means ""Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|yes|"def execute_command_tt1623205_90(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Red Herring
    # Definition: A clue or piece of information that is intended to be misleading, or distracting from the actual issue.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: ""Red Herring"" refers to a misleading clue or piece of information, so we need to analyze the frames where such clues or information might be present
    # 2. Detection of misleading clues: Analyze the frames for visual cues or dialogues that might be misleading or distracting
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Detect visual cues or dialogues that might be misleading or distracting
        misleading_clues = frame.find(""clue"")
        misleading_dialogues = frame.simple_query(""Is there any misleading dialogue?"")
        # Append infomation of frame to info dictionary
        info[f""Misleading clues in {i} th frame""] = misleading_clues
        info[f""Misleading dialogues in {i} th frame""] = misleading_dialogues
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1623205_90|"Is the trope ""Red Herring"", which means ""A clue that leads in the wrong direction."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1623205.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_0(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Big Bad
    # Definition: The character who is the direct cause of all of the bad happenings in a story.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Big Bad"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Big Bad"" usually involves a character who is the primary antagonist or the main source of conflict in the story
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the primary antagonist
        if frame.exists(""primary antagonist""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist action
            antagonist_action = frame.find(""primary antagonist"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of primary antagonist in {i} th frame""] = antagonist_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_0|"Is the trope ""Big Bad"", which means ""The character who is the direct cause of all of the bad happenings in a story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt1637725_3(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Smug Snake
    # Definition: A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Smug Snake"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Smug Snake"" usually involves a character with specific behavioral traits, like disdainful expressions, condescending speech, or interactions with other characters
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""villain""):
            # Query the character's behavior
            character_behavior = frame.find(""villain"")[0].simple_query(""How is the villain behaving?"")
            # Append infomation of frame to info dictionary
            info[f""Behavior of villain in {i} th frame""] = character_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_3|"Is the trope ""Smug Snake"", which means ""A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt1637725_5(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Would Hurt a Child
    # Definition: People that do hurt children, sometimes even kill them.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Would Hurt a Child"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Would Hurt a Child"" usually involves two characters like antagonist and child
    # 3. Action Analysis: For frames antagonist and child both present, the action like ""antagonist attacking"" or ""child is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and child
        if frame.exists(""antagonist"") and frame.exists(""child""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / child action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            child_action = frame.find(""child"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of child
            child_emotion = frame.simple_query(""What emotion does child have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of child in {i} th frame""] = child_action
            info[f""Child emotion in {i} th frame""] = child_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_5|"Is the trope ""Would Hurt a Child"", which means ""People that do hurt children, sometimes even kill them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt1637725_9(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Deadpan Snarker
    # Definition: A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Deadpan Snarker"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Deadpan Snarker"" usually involves a character who is prone to making sarcastic or witty remarks. We need to detect the presence of such a character and their actions.
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query the character's behavior
            character_behavior = frame.find(""character"")[0].simple_query(""What is the character doing?"")
            # Append infomation of frame to info dictionary
            info[f""Character behavior in {i} th frame""] = character_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_9|"Is the trope ""Deadpan Snarker"", which means ""A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
yes|no|"def execute_command_tt1637725_10(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]:
    # Trope: Determinator
    # Definition: A character, good or evil, male or female, young or old, who never gives up. Ever. No matter what.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Determinator"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Character Analysis: Identify characters who exhibit traits of determination, such as persistence, resilience, and unwavering commitment to their goals
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters
        characters = [""character1"", ""character2"", ""character3""]  # Example characters
        for character in characters:
            if frame.exists(character):
                # Query character's determination
                determination_query = frame.find(character)[0].simple_query(""Is the character showing determination?"")
                # Append infomation of frame to info dictionary
                info[f""Determination of {character} in {i} th frame""] = determination_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_10|"Is the trope ""Determinator"", which means ""A character \ good or evil, male or female, young or old \ who never gives up. Ever. No matter what."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt1637725_11(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Only Sane Man
    # Definition: When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only one who, well, isn't.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Only Sane Man"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Only Sane Man"" usually involves a group of characters, and one character who is the only sane man
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the group of characters and the only sane man
        if frame.exists(""group_of_characters"") and frame.exists(""only_sane_man""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the behavior of the group of characters and the only sane man
            group_behavior = frame.find(""group_of_characters"")[0].simple_query(""What are the characters doing?"")
            sane_man_behavior = frame.find(""only_sane_man"")[0].simple_query(""What is the only sane man doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Behavior of the group of characters in {i} th frame""] = group_behavior
            info[f""Behavior of the only sane man in {i} th frame""] = sane_man_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_11|"Is the trope ""Only Sane Man"", which means ""When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only 
one who, well, isn't."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt1637725_17(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Too Dumb to Live
    # Definition: People who are so stupid that they simply do not deserve to survive.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Too Dumb to Live"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Too Dumb to Live"" usually involves a character making a series of poor decisions or being oblivious to obvious danger
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query character's decision-making
            decision_making = frame.find(""character"")[0].simple_query(""What is the character doing?"")
            # Query character's awareness of danger
            danger_awareness = frame.find(""character"")[0].simple_query(""Is the character aware of the danger?"")
            # Append infomation of frame to info dictionary
            info[f""Decision-making of character in {i} th frame""] = decision_making
            info[f""Danger awareness of character in {i} th frame""] = danger_awareness
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_17|"Is the trope ""Too Dumb to Live"", which means ""People who are so stupid that they simply do not deserve to survive."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_20(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adorkable
    # Definition: An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character an endearing vulnerability.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adorkable"" character might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adorkable"" character usually involves a character with socially inept, shy or clumsy behavior
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify adorkable character
        if frame.exists(""adorkable character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query adorkable character's behavior
            behavior = frame.find(""adorkable character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Behavior of adorkable character in {i} th frame""] = behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_20|"Is the trope ""Adorkable"", which means ""An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character 
an endearing vulnerability."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_28(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adult Fear
    # Definition: Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adult Fear"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adult Fear"" usually involves mature, well-adjusted adults and their concerns
    # 3. Contextual Analysis: For frames involving mature, well-adjusted adults, analyze the context for concerns that are relevant to adults
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify mature, well-adjusted adults and their concerns
        if frame.exists(""mature, well-adjusted adult"") and frame.exists(""concern""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the specific concern
            concern_query = frame.simple_query(""What is the concern?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Concern in {i} th frame""] = concern_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_28|"Is the trope ""Adult Fear"", which means ""Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_29(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Not So Different
    # Definition: When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more than the other character would want to believe.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Not So Different"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Not So Different"" usually involves two characters, so we need to detect the presence of two characters and their interactions
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the two characters
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the interaction between the two characters
            interaction_query = frame.simple_query(""What is the interaction between the two characters?"")
            # Append infomation of frame to info dictionary
            info[f""Interaction in {i} th frame""] = interaction_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_29|"Is the trope ""Not So Different"", which means ""When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more 
than the other character would want to believe."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_32(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Eye Scream
    # Definition: When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the invasion of the eye sockets by a foreign body.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Eye Scream"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Eye Scream"" usually involves a character's face and a foreign object near the eyes
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify character's face and foreign object
        if frame.exists(""face"") and frame.exists(""foreign object""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the presence of foreign object near the eyes
            eye_scream_query = frame.simple_query(""Is there a foreign object near the eyes?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Eye Scream in {i} th frame""] = eye_scream_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_32|"Is the trope ""Eye Scream"", which means ""When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the 
invasion of the eye sockets by a foreign body."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_46(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Screw This, I'm Outta Here!
    # Definition: a character decides to leave, often in a dramatic or humorous fashion, due to frustration, anger, or a sense of hopelessness
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Screw This, I'm Outta Here!"" can happen at any point in the video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Look for visual cues of a character's frustration, anger, or departure
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character and their emotions
        if frame.exists(""character""):
            # Query the character's emotions
            character_emotion = frame.find(""character"")[0].simple_query(""What is the character's emotion?"")
            # Query the character's action
            character_action = frame.find(""character"")[0].simple_query(""What is the character doing?"")
            # Append infomation of frame to info dictionary
            info[f""Emotion of character in {i} th frame""] = character_emotion
            info[f""Action of character in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_46|"Is the trope ""Screw This, I'm Outta Here!"", which means ""Screw you guys, I'm going home."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
yes|no|"def execute_command_tt1637725_47(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Kick the Dog
    # Definition: an act of cruelty by a character, typically towards a more vulnerable or defenseless entity, to establish the character's malevolence
    # Thought: we devide the trope detection into 4 steps
    # 1. Frame Selection: Since ""Kick the Dog"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Kick the Dog"" usually involves two characters like antagonist and victim(for example animal, child or visibly weakly character)
    # 3. Action Analysis: For frames antagonist and victim both present, the action like ""antagonist attacking"" or ""victim is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and victim
        if frame.exists(""antagonist"") and frame.exists(""victim""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / victim action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            victim_action = frame.find(""victim"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of victim`    
            victim_emotion = frame.simple_query(""What emotion does victim have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of victim in {i} th frame""] = victim_action
            info[f""Victim emotion in {i} th frame""] = victim_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_47|"Is the trope ""Kick the Dog"", which means ""When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift 
audience sympathy away from him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt1637725_62(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Blatant Lies
    # Definition: A glaringly obvious lie.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: Since ""Blatant Lies"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Blatant Lies"" usually involves characters, especially the one who is lying and the one who is being lied to
    # 3. Action Analysis: For frames both characters present, the action like ""lying"" or ""showing signs of disbelief"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify liar and victim
        if frame.exists(""liar"") and frame.exists(""victim""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query liar / victim action
            liar_action = frame.find(""liar"")[0].simple_query(""What is he/she doing?"")
            victim_reaction = frame.find(""victim"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of liar in {i} th frame""] = liar_action
            info[f""Reaction of victim in {i} th frame""] = victim_reaction
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_62|"Is the trope ""Blatant Lies"", which means ""A glaringly obvious lie."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_71(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Irony
    # Definition: The intended meaning is an inversion of the plain meaning.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Irony"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Irony"" usually involves two characters or objects, one of which is expected to behave or appear in a certain way, but does the opposite
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters or objects
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the actions or appearances of the characters or objects
            character1_action = frame.find(""character1"")[0].simple_query(""What is character1 doing?"")
            character2_action = frame.find(""character2"")[0].simple_query(""What is character2 doing?"")
            # Append infomation of frame to info dictionary
            info[f""Action of character1 in {i} th frame""] = character1_action
            info[f""Action of character2 in {i} th frame""] = character2_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_71|"Is the trope ""Irony"", which means ""The intended meaning is an inversion of the plain meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
yes|no|"def execute_command_tt1637725_73(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Stealth Pun
    # Definition: The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Stealth Pun"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Detect objects or characters that are likely to be involved in a pun or joke
    # 3. Contextual Analysis: Analyze the context and dialogue in the frames for subtle or hidden jokes or puns
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters and objects
        if frame.exists(""character"") and frame.exists(""object""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query for any subtle or hidden jokes or puns
            pun_query = frame.simple_query(""Is there any hidden joke or pun?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Pun in {i} th frame""] = pun_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_73|"Is the trope ""Stealth Pun"", which means ""The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_74(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Bittersweet Ending
    # Definition: When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some irrevocable loss has happened during the course of the events, and nothing will ever be the same again.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: ""Bittersweet Ending"" refers to an ending, so we only analyze the final part of video segment
    # 2. Detection of emotional and contextual cues: Analyze the frames for visual cues of bittersweetness, such as mixed emotions, irrevocable loss, or significant change
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    for i, frame in enumerate(ending_segment.frame_iterator()):
        # Detect visual cues of bittersweetness
        mixed_emotions_query = frame.simple_query(""Are there mixed emotions?"")
        irrevocable_loss_query = frame.simple_query(""Is there irrevocable loss or significant change?"")
        if ""yes"" in mixed_emotions_query or ""yes"" in irrevocable_loss_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there any bittersweetness present in the frame?"")
            info[f""Caption of {ending_segment.start + 1} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_74|"Is the trope ""Bittersweet Ending"", which means ""When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some 
irrevocable loss has happened during the course of the events, and nothing will ever be the same again."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_82(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: ""What the Hell, Hero?""
    # Definition: When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""What the Hell, Hero?"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""What the Hell, Hero?"" usually involves two characters like protagonist and other character calling out the protagonist
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify protagonist and other character
        if frame.exists(""protagonist"") and frame.exists(""other character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query protagonist / other character action
            protagonist_action = frame.find(""protagonist"")[0].simple_query(""What is he/she doing?"")
            other_character_action = frame.find(""other character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of protagonist in {i} th frame""] = protagonist_action
            info[f""Action of other character in {i} th frame""] = other_character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_82|"Is the trope ""What the Hell, Hero?"", which means ""When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
yes|no|"def execute_command_tt1637725_89(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Chekhov's Gunman
    # Definition: Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode.
    # Thought: we devide the trope detection into 3 steps
    # 1. Character Identification: Identify characters that are introduced early in the video and seem unimportant at first
    # 2. Character Relevance: Analyze the actions and interactions of these characters to determine if they become important later in the video
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the first 10% of the video is a reasonable segment to analyze for the introduction of characters
    intro_segment_end = int(video_segment.num_frames * 0.1)
    intro_segment = video_segment.trim(end=intro_segment_end)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    for i, frame in enumerate(intro_segment.frame_iterator()):
        # Detect characters introduced early in the video
        characters = [""character1"", ""character2"", ""character3""]  # Assuming we have a function to detect characters
        for character in characters:
            if frame.exists(character):
                # Query the relevance of the character later in the video
                relevance_query = frame.find(character)[0].simple_query(""Is this character important later?"")
                info[f""Relevance of {character} in {intro_segment.start + 1} th frame""] = relevance_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_89|"Is the trope ""Chekhov's Gunman"", which means ""Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|no|"def execute_command_tt1637725_90(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Red Herring
    # Definition: A clue that leads in the wrong direction.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Red Herring"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Red Herring"" usually involves a misleading clue or object that diverts attention from the actual solution or plot development
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify misleading clues or objects
        if frame.exists(""misleading clue""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1637725_90|"Is the trope ""Red Herring"", which means ""A clue that leads in the wrong direction."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1637725.mp4|['yes', 'no']
no|yes|"def execute_command_tt0100157_0(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Big Bad
    # Definition: The character who is the direct cause of all of the bad happenings in a story.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Big Bad"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Big Bad"" usually involves a character who is the primary antagonist or the main source of conflict in the story
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the primary antagonist
        if frame.exists(""primary antagonist""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist action
            antagonist_action = frame.find(""primary antagonist"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of primary antagonist in {i} th frame""] = antagonist_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_0|"Is the trope ""Big Bad"", which means ""The character who is the direct cause of all of the bad happenings in a story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_3(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Smug Snake
    # Definition: A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Smug Snake"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Smug Snake"" usually involves a specific character with certain behavioral traits. We need to detect the presence of this character and analyze their behavior.
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the ""Smug Snake"" character
        if frame.exists(""Smug Snake""):
            # Query the behavior of the ""Smug Snake"" character
            behavior_query = frame.find(""Smug Snake"")[0].simple_query(""How is the character behaving?"")
            # Append infomation of frame to info dictionary
            info[f""Behavior of Smug Snake in {i} th frame""] = behavior_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_3|"Is the trope ""Smug Snake"", which means ""A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|yes|"def execute_command_tt0100157_5(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Would Hurt a Child
    # Definition: People that do hurt children, sometimes even kill them.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Would Hurt a Child"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Would Hurt a Child"" usually involves two characters like antagonist and child
    # 3. Action Analysis: For frames antagonist and child both present, the action like ""antagonist attacking"" or ""child is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and child
        if frame.exists(""antagonist"") and frame.exists(""child""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / child action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            child_action = frame.find(""child"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of child`    
            child_emotion = frame.simple_query(""What emotion does child have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of child in {i} th frame""] = child_action
            info[f""Child emotion in {i} th frame""] = child_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_5|"Is the trope ""Would Hurt a Child"", which means ""People that do hurt children, sometimes even kill them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|yes|"def execute_command_tt0100157_9(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Deadpan Snarker
    # Definition: A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Deadpan Snarker"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Deadpan Snarker"" usually involves a character who is prone to making sarcastic or witty remarks. We need to detect such characters and their dialogues
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters and their dialogues
        characters = frame.find(""character"")
        for character in characters:
            # Detect if the character is making sarcastic or witty remarks
            sarcastic_remarks = character.simple_query(""Is the character making sarcastic or witty remarks?"")
            if ""yes"" in sarcastic_remarks:
                # Caption the frame
                caption = frame.simple_query(""What is happening?"")
                info[f""Caption of {i} th frame""] = caption
                info[f""Character making sarcastic remarks in {i} th frame""] = character
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_9|"Is the trope ""Deadpan Snarker"", which means ""A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|no|"def execute_command_tt0100157_10(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Determinator
    # Definition: A character, good or evil, male or female, young or old, who never gives up. Ever. No matter what.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Determinator"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Determinator"" usually involves a character showing extraordinary determination, persistence, and resilience
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""determinator""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query character's action
            character_action = frame.find(""determinator"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of determinator in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_10|"Is the trope ""Determinator"", which means ""A character \ good or evil, male or female, young or old \ who never gives up. Ever. No matter what."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|no|"def execute_command_tt0100157_11(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Only Sane Man
    # Definition: When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only one who, well, isn't.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Only Sane Man"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Only Sane Man"" usually involves a group of characters, and one character is acting differently from the rest
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the group of characters and the character acting differently
        group_of_characters = frame.find(""group_of_characters"")
        character_acting_differently = frame.find(""character_acting_differently"")
        if len(group_of_characters) > 1 and len(character_acting_differently) == 1:
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the character acting differently
            character_action = character_acting_differently[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of character acting differently in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_11|"Is the trope ""Only Sane Man"", which means ""When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only 
one who, well, isn't."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|yes|"def execute_command_tt0100157_17(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Too Dumb to Live
    # Definition: People who are so stupid that they simply do not deserve to survive.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Too Dumb to Live"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Too Dumb to Live"" usually involves a character or characters making decisions that are so obviously stupid that they should result in their immediate demise
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the main character
        if frame.exists(""main character""):
            # Query the main character's decision-making
            decision_query = frame.simple_query(""Is the main character making a stupid decision?"")
            # Append infomation of frame to info dictionary
            info[f""Decision of main character in {i} th frame""] = decision_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_17|"Is the trope ""Too Dumb to Live"", which means ""People who are so stupid that they simply do not deserve to survive."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_20(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adorkable
    # Definition: An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character an endearing vulnerability.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adorkable"" character might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adorkable"" character might have specific visual cues like shy or clumsy behavior, or specific settings that indicate their social ineptitude
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify adorkable character
        if frame.exists(""adorkable_character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query adorkable character's behavior
            behavior = frame.find(""adorkable_character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Behavior of adorkable character in {i} th frame""] = behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_20|"Is the trope ""Adorkable"", which means ""An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character 
an endearing vulnerability."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|yes|"def execute_command_tt0100157_28(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adult Fear
    # Definition: Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adult Fear"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adult Fear"" usually involves mature, well-adjusted adults and their concerns
    # 3. Contextual Analysis: For frames involving mature, well-adjusted adults, analyze the context for concerns that are relevant to adults
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify mature, well-adjusted adults and their concerns
        if frame.exists(""mature, well-adjusted adult""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the concerns of mature, well-adjusted adults
            adult_concerns = frame.simple_query(""What are the concerns of the mature, well-adjusted adult?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Concerns of mature, well-adjusted adult in {i} th frame""] = adult_concerns
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_28|"Is the trope ""Adult Fear"", which means ""Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|no|"def execute_command_tt0100157_29(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Not So Different
    # Definition: When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more than the other character would want to believe.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Not So Different"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Not So Different"" usually involves two characters, so we need to detect the presence of two characters and their interactions
    # 3. Contextual Analysis: For frames with both characters present, analyze their actions, expressions, and dialogues for signs of similarity or realization of commonalities
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the two characters
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the interaction between the two characters
            interaction_query = frame.simple_query(""What is the interaction between character1 and character2?"")
            # Append infomation of frame to info dictionary
            info[f""Interaction in {i} th frame""] = interaction_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_29|"Is the trope ""Not So Different"", which means ""When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more 
than the other character would want to believe."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_32(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Eye Scream
    # Definition: When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the invasion of the eye sockets by a foreign body.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Eye Scream"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Eye Scream"" usually involves a character's face and a foreign object near the eyes
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify character's face and foreign object near the eyes
        if frame.exists(""character's face"") and frame.exists(""foreign object near the eyes""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the presence of foreign object near the eyes
            foreign_object_query = frame.simple_query(""Is there a foreign object near the eyes?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Foreign object near the eyes in {i} th frame""] = foreign_object_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_32|"Is the trope ""Eye Scream"", which means ""When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the 
invasion of the eye sockets by a foreign body."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_46(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Screw This, I'm Outta Here!
    # Definition: a character decides to leave, quit, or abandon a situation, often in a dramatic or humorous fashion
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Screw This, I'm Outta Here!"" can happen at any point in the video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Look for visual cues of a character leaving or abandoning a situation
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query the character's action
            character_action = frame.find(""character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Action of character in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_46|"Is the trope ""Screw This, I'm Outta Here!"", which means ""Screw you guys, I'm going home."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_47(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Kick the Dog
    # Definition: an act of cruelty by a character, typically towards a more vulnerable or defenseless entity, to establish the character's malevolence
    # Thought: we devide the trope detection into 4 steps
    # 1. Frame Selection: Since ""Kick the Dog"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Kick the Dog"" usually involves two characters like antagonist and victim(for example animal, child or visibly weakly character)
    # 3. Action Analysis: For frames antagonist and victim both present, the action like ""antagonist attacking"" or ""victim is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and victim
        if frame.exists(""antagonist"") and frame.exists(""victim""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / victim action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            victim_action = frame.find(""victim"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of victim`    
            victim_emotion = frame.simple_query(""What emotion does victim have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of victim in {i} th frame""] = victim_action
            info[f""Victim emotion in {i} th frame""] = victim_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_47|"Is the trope ""Kick the Dog"", which means ""When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift 
audience sympathy away from him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_62(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Blatant Lies
    # Definition: A glaringly obvious lie.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Blatant Lies"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Blatant Lies"" usually involves characters, so we need to detect the presence of characters and their facial expressions
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters and their facial expressions
        if frame.exists(""character""):
            # Query the facial expression of the character
            facial_expression = frame.find(""character"")[0].simple_query(""What is the facial expression?"")
            # Append infomation of frame to info dictionary
            info[f""Facial expression of character in {i} th frame""] = facial_expression
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_62|"Is the trope ""Blatant Lies"", which means ""A glaringly obvious lie."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|yes|"def execute_command_tt0100157_71(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Irony
    # Definition: The intended meaning is an inversion of the plain meaning.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Irony"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Irony"" usually involves two characters or objects, one of which is expected to behave or appear in a certain way, but does the opposite
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters or objects
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the actions or behaviors of the characters or objects
            character1_action = frame.find(""character1"")[0].simple_query(""What is character1 doing?"")
            character2_action = frame.find(""character2"")[0].simple_query(""What is character2 doing?"")
            # Append infomation of frame to info dictionary
            info[f""Action of character1 in {i} th frame""] = character1_action
            info[f""Action of character2 in {i} th frame""] = character2_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_71|"Is the trope ""Irony"", which means ""The intended meaning is an inversion of the plain meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
yes|yes|"def execute_command_tt0100157_73(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Stealth Pun
    # Definition: The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Stealth Pun"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Detect objects or characters that are likely to be involved in a pun or joke
    # 3. Pun Analysis: Analyze the dialogue or visual elements for hidden jokes or puns
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters and objects
        if frame.exists(""character"") and frame.exists(""object""):
            # Query for puns or jokes
            pun_query = frame.simple_query(""Is there a hidden joke or pun?"")
            # Append infomation of frame to info dictionary
            info[f""Pun in {i} th frame""] = pun_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_73|"Is the trope ""Stealth Pun"", which means ""The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_74(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Bittersweet Ending
    # Definition: When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some irrevocable loss has happened during the course of the events, and nothing will ever be the same again.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: ""Bittersweet Ending"" refers to an ending, so we only analyze the final part of video segment
    # 2. Detection of emotional and contextual cues: Analyze the frames for visual cues of bittersweetness, such as mixed emotions, irrevocable loss, or significant change
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    for i, frame in enumerate(ending_segment.frame_iterator()):
        # Detect visual cues of bittersweetness
        mixed_emotions_query = frame.simple_query(""Are there mixed emotions?"")
        irrevocable_loss_query = frame.simple_query(""Is there irrevocable loss or significant change?"")
        if ""yes"" in mixed_emotions_query or ""yes"" in irrevocable_loss_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there any mixed emotions or irrevocable loss present in the frame?"")
            info[f""Caption of {ending_segment.start + 1} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_74|"Is the trope ""Bittersweet Ending"", which means ""When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some 
irrevocable loss has happened during the course of the events, and nothing will ever be the same again."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_82(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: What the Hell, Hero?
    # Definition: When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""What the Hell, Hero?"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""What the Hell, Hero?"" usually involves two characters like protagonist and other characters
    # 3. Action Analysis: For frames protagonist and other characters both present, the action like ""protagonist doing something unheroic"" or ""other characters calling out protagonist"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify protagonist and other characters
        if frame.exists(""protagonist"") and frame.exists(""other characters""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query protagonist / other characters action
            protagonist_action = frame.find(""protagonist"")[0].simple_query(""What is he/she doing?"")
            other_characters_action = frame.find(""other characters"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of protagonist in {i} th frame""] = protagonist_action
            info[f""Action of other characters in {i} th frame""] = other_characters_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_82|"Is the trope ""What the Hell, Hero?"", which means ""When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|no|"def execute_command_tt0100157_89(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Chekhov's Gunman
    # Definition: Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode.
    # Thought: we devide the trope detection into 3 steps
    # 1. Character Identification: Identify characters that are introduced early in the video and seem unimportant at first
    # 2. Character Relevance: Analyze the actions and interactions of these characters to determine if they become important later in the video
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the first 10% of the video is a reasonable segment to analyze for character introduction
    intro_segment_end = int(video_segment.num_frames * 0.1)
    intro_segment = video_segment.trim(end=intro_segment_end)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    # Identify characters introduced early in the video
    characters = [""character1"", ""character2"", ""character3""]  # Replace with actual character names
    for character in characters:
        # Check if the character is present in the introduction segment
        character_present = intro_segment.exists(character)
        if character_present:
            # Analyze the relevance of the character in the later part of the video
            character_relevance = video_segment.exists(character)
            info[f""{character} introduced""] = ""yes""
            info[f""{character} becomes relevant later""] = bool_to_yesno(character_relevance)
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_89|"Is the trope ""Chekhov's Gunman"", which means ""Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|yes|"def execute_command_tt0100157_90(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Red Herring
    # Definition: A clue that leads in the wrong direction.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Red Herring"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Red Herring"" usually involves a misleading clue or object that diverts attention from the actual solution or plot development
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify misleading clues or objects
        if frame.exists(""misleading clue"") or frame.exists(""diverting object""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt0100157_90|"Is the trope ""Red Herring"", which means ""A clue that leads in the wrong direction."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0100157.mp4|['yes', 'no']
no|yes|"def execute_command_tt1300851_0(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Big Bad
    # Definition: The character who is the direct cause of all of the bad happenings in a story.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Big Bad"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Big Bad"" usually involves a character who is the primary antagonist or the main source of conflict in the story
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the primary antagonist
        if frame.exists(""primary antagonist""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist action
            antagonist_action = frame.find(""primary antagonist"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of primary antagonist in {i} th frame""] = antagonist_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_0|"Is the trope ""Big Bad"", which means ""The character who is the direct cause of all of the bad happenings in a story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
yes|no|"def execute_command_tt1300851_3(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Smug Snake
    # Definition: A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Smug Snake"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Smug Snake"" usually involves a character with specific behavioral traits, like disdainful facial expressions, condescending speech, or interactions that demonstrate disdain
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""villain""):
            # Query the character's behavior
            disdainful_expression = frame.find(""villain"")[0].simple_query(""Does the villain have a disdainful expression?"")
            condescending_speech = frame.find(""villain"")[0].simple_query(""Is the villain speaking in a condescending manner?"")
            # Append infomation of frame to info dictionary
            info[f""Disdainful expression of villain in {i} th frame""] = disdainful_expression
            info[f""Condescending speech of villain in {i} th frame""] = condescending_speech
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_3|"Is the trope ""Smug Snake"", which means ""A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_5(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Would Hurt a Child
    # Definition: People that do hurt children, sometimes even kill them.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Would Hurt a Child"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Would Hurt a Child"" usually involves two characters like antagonist and child
    # 3. Action Analysis: For frames antagonist and child both present, the action like ""antagonist attacking"" or ""child is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and child
        if frame.exists(""antagonist"") and frame.exists(""child""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / child action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            child_action = frame.find(""child"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of child
            child_emotion = frame.find(""child"")[0].simple_query(""What emotion does child have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of child in {i} th frame""] = child_action
            info[f""Child emotion in {i} th frame""] = child_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_5|"Is the trope ""Would Hurt a Child"", which means ""People that do hurt children, sometimes even kill them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_9(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Deadpan Snarker
    # Definition: A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Deadpan Snarker"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Deadpan Snarker"" usually involves a character who is prone to making sarcastic or witty remarks. We need to detect the presence of such a character and their actions.
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character prone to making sarcastic or witty remarks
        if frame.exists(""sarcastic character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the character's action
            character_action = frame.find(""sarcastic character"")[0].simple_query(""What is he/she doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of sarcastic character in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_9|"Is the trope ""Deadpan Snarker"", which means ""A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
yes|no|"def execute_command_tt1300851_10(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Determinator
    # Definition: A character, good or evil, male or female, young or old, who never gives up. Ever. No matter what.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Determinator"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Character Analysis: ""Determinator"" is a character trope, so we need to identify the character(s) that exhibit this trait. This could involve detecting specific actions, facial expressions, or dialogue that indicate unwavering determination.
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the main character
        if frame.exists(""main character""):
            # Query the main character's determination
            determination_query = frame.find(""main character"")[0].simple_query(""Is the main character showing determination?"")
            # Append infomation of frame to info dictionary
            info[f""Determination of main character in {i} th frame""] = determination_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_10|"Is the trope ""Determinator"", which means ""A character \ good or evil, male or female, young or old \ who never gives up. Ever. No matter what."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_11(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Only Sane Man
    # Definition: When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only one who, well, isn't.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Only Sane Man"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Only Sane Man"" usually involves a group of characters, and one character who is the only sane person
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the group of characters and the only sane man
        if frame.exists(""group_of_characters"") and frame.exists(""only_sane_man""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the behavior of the only sane man
            sane_man_behavior = frame.find(""only_sane_man"")[0].simple_query(""What is the only sane man doing?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Behavior of the only sane man in {i} th frame""] = sane_man_behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_11|"Is the trope ""Only Sane Man"", which means ""When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only 
one who, well, isn't."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|yes|"def execute_command_tt1300851_17(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Too Dumb to Live
    # Definition: People who are so stupid that they simply do not deserve to survive.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Too Dumb to Live"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Too Dumb to Live"" usually involves a character making a series of poor decisions or being oblivious to danger
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query character's decision-making
            decision_making = frame.find(""character"")[0].simple_query(""What is the character doing?"")

            # Append infomation of frame to info dictionary
            info[f""Decision making of character in {i} th frame""] = decision_making
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_17|"Is the trope ""Too Dumb to Live"", which means ""People who are so stupid that they simply do not deserve to survive."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_20(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adorkable
    # Definition: An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character an endearing vulnerability.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adorkable"" character might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adorkable"" character might have specific visual cues like shy or clumsy behavior, or specific character traits
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify adorkable character
        if frame.exists(""adorkable_character""):
            # Query the character traits
            character_traits = frame.find(""adorkable_character"")[0].simple_query(""What are the character traits?"")
            # Query the behavior
            behavior = frame.find(""adorkable_character"")[0].simple_query(""What is the behavior?"")
            # Append infomation of frame to info dictionary
            info[f""Character traits of adorkable character in {i} th frame""] = character_traits
            info[f""Behavior of adorkable character in {i} th frame""] = behavior
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_20|"Is the trope ""Adorkable"", which means ""An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character 
an endearing vulnerability."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_28(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Adult Fear
    # Definition: Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Adult Fear"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Adult Fear"" usually involves mature, well-adjusted adults and their concerns
    # 3. Contextual Analysis: For frames involving mature, well-adjusted adults, we analyze the context to determine if their concerns are relevant to the trope
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify mature, well-adjusted adults and their concerns
        if frame.exists(""mature, well-adjusted adult"") and frame.exists(""concern""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the nature of the concern
            concern_nature = frame.find(""concern"")[0].simple_query(""What is the nature of the concern?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Nature of concern in {i} th frame""] = concern_nature
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_28|"Is the trope ""Adult Fear"", which means ""Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_29(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Not So Different
    # Definition: When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more than the other character would want to believe.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Not So Different"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Not So Different"" usually involves two characters, so we need to detect the presence of two characters and their interactions
    # 3. Context Analysis: For frames with both characters present, analyze their interactions, dialogues, or visual cues that suggest they have more in common than they realize
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the two characters
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query their interactions
            interaction_query = frame.simple_query(""What are the characters doing? Are they interacting?"")
            # Query their dialogues
            dialogue_query = frame.simple_query(""What are they talking about?"")
            # Append infomation of frame to info dictionary
            info[f""Interaction in {i} th frame""] = interaction_query
            info[f""Dialogue in {i} th frame""] = dialogue_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_29|"Is the trope ""Not So Different"", which means ""When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more 
than the other character would want to believe."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
yes|no|"def execute_command_tt1300851_32(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]:
    # Trope: Eye Scream
    # Definition: When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the invasion of the eye sockets by a foreign body.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Eye Scream"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Eye Scream"" usually involves a character's face and a foreign object near the eyes
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify character's face and foreign object
        if frame.exists(""character's face"") and frame.exists(""foreign object near the eyes""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query the presence of invasion of the eye sockets by a foreign body
            invasion_query = frame.simple_query(""Is there invasion of the eye sockets by a foreign body?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Invasion of the eye sockets by a foreign body in {i} th frame""] = invasion_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_32|"Is the trope ""Eye Scream"", which means ""When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the 
invasion of the eye sockets by a foreign body."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_46(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Screw This, I'm Outta Here!
    # Definition: a character decides to leave a situation, often in a dramatic or humorous fashion, to express frustration or disinterest
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Screw This, I'm Outta Here!"" is a character's decision, we need to analyze the frames where the character is present
    # 2. Character's Expression Analysis: Analyze the character's facial expressions, body language, and the context of the scene to detect frustration, disinterest, or dramatic exit
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify the character
        if frame.exists(""character""):
            # Query character's expression and action
            character_expression = frame.find(""character"")[0].simple_query(""What is the character's expression?"")
            character_action = frame.find(""character"")[0].simple_query(""What is the character doing?"")
            # Append infomation of frame to info dictionary
            info[f""Expression of character in {i} th frame""] = character_expression
            info[f""Action of character in {i} th frame""] = character_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_46|"Is the trope ""Screw This, I'm Outta Here!"", which means ""Screw you guys, I'm going home."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_47(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Kick the Dog
    # Definition: an act of cruelty by a character, typically towards a more vulnerable or defenseless entity, to establish the character's malevolence
    # Thought: we devide the trope detection into 4 steps
    # 1. Frame Selection: Since ""Kick the Dog"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Kick the Dog"" usually involves two characters like antagonist and victim(for example animal, child or visibly weakly character)
    # 3. Action Analysis: For frames antagonist and victim both present, the action like ""antagonist attacking"" or ""victim is showing signs of distress"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify antagonist and victim
        if frame.exists(""antagonist"") and frame.exists(""victim""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query antagonist / victim action
            antagonist_action = frame.find(""antagonist"")[0].simple_query(""What is he/she doing?"")
            victim_action = frame.find(""victim"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of victim`    
            victim_emotion = frame.simple_query(""What emotion does victim have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of antagonist in {i} th frame""] = antagonist_action
            info[f""Action of victim in {i} th frame""] = victim_action
            info[f""Victim emotion in {i} th frame""] = victim_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_47|"Is the trope ""Kick the Dog"", which means ""When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift 
audience sympathy away from him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_62(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Blatant Lies
    # Definition: A glaringly obvious lie.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: Since ""Blatant Lies"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Blatant Lies"" usually involves a character or characters telling a lie, which can be detected through facial expressions, dialogue, or other visual cues
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters and detect lies
        if frame.exists(""character"") and frame.exists(""lie""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query character's dialogue
            dialogue = frame.find(""character"")[0].simple_query(""What is he/she saying?"")
            # Query character's facial expression
            facial_expression = frame.find(""character"")[0].simple_query(""What is his/her facial expression?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Dialogue of character in {i} th frame""] = dialogue
            info[f""Facial expression of character in {i} th frame""] = facial_expression
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_62|"Is the trope ""Blatant Lies"", which means ""A glaringly obvious lie."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_71(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Irony
    # Definition: The intended meaning is an inversion of the plain meaning. 
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Irony"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Irony"" usually involves two characters or objects, one of which is expected to behave or appear in a certain way, but does the opposite
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify characters or objects
        if frame.exists(""character1"") and frame.exists(""character2""):
            # Query the actions or behaviors of the characters or objects
            character1_action = frame.find(""character1"")[0].simple_query(""What is character1 doing?"")
            character2_action = frame.find(""character2"")[0].simple_query(""What is character2 doing?"")
            # Append infomation of frame to info dictionary
            info[f""Action of character1 in {i} th frame""] = character1_action
            info[f""Action of character2 in {i} th frame""] = character2_action
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_71|"Is the trope ""Irony"", which means ""The intended meaning is an inversion of the plain meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_73(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Stealth Pun
    # Definition: The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Stealth Pun"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: Detect objects or scenes that might contain a hidden joke or pun
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify objects or scenes that might contain a hidden joke or pun
        pun_objects = frame.find(""pun"")
        pun_scenes = frame.find(""joke"")
        # Append infomation of frame to info dictionary
        info[f""Pun objects in {i} th frame""] = pun_objects
        info[f""Joke scenes in {i} th frame""] = pun_scenes
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_73|"Is the trope ""Stealth Pun"", which means ""The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
yes|yes|"def execute_command_tt1300851_74(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Bittersweet Ending
    # Definition: When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some irrevocable loss has happened during the course of the events, and nothing will ever be the same again.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame selection: ""Bittersweet Ending"" refers to an ending, so we only analyze the final part of video segment
    # 2. Detection of emotional and contextual cues: Analyze the frames for visual cues of bittersweetness, such as mixed emotions, irrevocable loss, or significant change
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)
    # Create a info dictionary
    info = {
        ""Total number of frames"": video_segment.num_frames
    }
    for i, frame in enumerate(ending_segment.frame_iterator()):
        # Detect visual cues of bittersweetness
        mixed_emotions_query = frame.simple_query(""Are there mixed emotions?"")
        irrevocable_loss_query = frame.simple_query(""Is there irrevocable loss or significant change?"")
        if ""yes"" in mixed_emotions_query or ""yes"" in irrevocable_loss_query:
            # Caption the frame
            caption = frame.simple_query(""What is in the frame? Is there any mixed emotions or irrevocable loss present in the frame?"")
            info[f""Caption of {ending_segment.start + 1} th frame""] = caption
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_74|"Is the trope ""Bittersweet Ending"", which means ""When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some 
irrevocable loss has happened during the course of the events, and nothing will ever be the same again."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_82(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: What the Hell, Hero?
    # Definition: When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""What the Hell, Hero?"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""What the Hell, Hero?"" usually involves two characters like hero and other characters
    # 3. Action Analysis: For frames hero and other characters both present, the action like ""other characters calling out hero"" or ""hero showing signs of guilt"" are possibly taking place
    # 4. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify hero and other characters
        if frame.exists(""hero"") and frame.exists(""other characters""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Query hero / other characters action
            hero_action = frame.find(""hero"")[0].simple_query(""What is he/she doing?"")
            other_characters_action = frame.find(""other characters"")[0].simple_query(""What is he/she doing?"")
            # Query emotion condition of hero`    
            hero_emotion = frame.simple_query(""What emotion does hero have?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
            info[f""Action of hero in {i} th frame""] = hero_action
            info[f""Action of other characters in {i} th frame""] = other_characters_action
            info[f""Hero emotion in {i} th frame""] = hero_emotion
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_82|"Is the trope ""What the Hell, Hero?"", which means ""When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_89(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Chekhov's Gunman
    # Definition: Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode.
    # Thought: we devide the trope detection into 3 steps
    # 1. Character Identification: We need to identify characters who are introduced innocuously and unimportantly
    # 2. Character Tracking: Track the presence and actions of these characters throughout the video
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a list to store the characters introduced innocuously
    innocuous_characters = []
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify innocuous characters
        innocuous_characters_in_frame = frame.find(""innocuous_character"")
        innocuous_characters.extend(innocuous_characters_in_frame)
    # Create a dictionary to store the presence and actions of these characters
    character_info = {}
    for character in innocuous_characters:
        # Track the presence and actions of the innocuous characters
        character_presence = character.exists_in(video_segment)
        character_actions = character.actions_in(video_segment)
        character_info[character.name] = {
            ""Presence"": character_presence,
            ""Actions"": character_actions
        }
    # Answer the query
    answer = video_segment.select_answer(character_info, query, possible_answers)
    return answer"|tt1300851_89|"Is the trope ""Chekhov's Gunman"", which means ""Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
no|no|"def execute_command_tt1300851_90(video, possible_answers, query, ImagePatch, VideoSegment, llm_query, bool_to_yesno, distance, best_image_match):
    # Answer is:def execute_command(video, possible_answers, query)->[str, dict]
    # Trope: Red Herring
    # Definition: A clue or piece of information that is intended to be misleading, or distracting from the actual issue.
    # Thought: we devide the trope detection into 3 steps
    # 1. Frame Selection: Since ""Red Herring"" might present in every moment of video, we iterate every frame and perform a series of queries, collect information for each candidate frame
    # 2. Object Detection: ""Red Herring"" usually involves a misleading clue or piece of information, which might be a specific object or character
    # 3. Answer Selection: Use select_answer api to select the most possible answer with previously collected information 
    video_segment = VideoSegment(video)
    # Create a info dictionary
    info = {}
    for i, frame in tqdm(enumerate(video_segment.frame_iterator()), total=video_segment.num_frames):
        # Assuming functions exist to identify misleading objects or characters
        if frame.exists(""misleading_object"") or frame.exists(""misleading_character""):
            # Caption the frame
            caption_query = frame.simple_query(""What is happening?"")
            # Append infomation of frame to info dictionary
            info[f""Caption of {i} th frame""] = caption_query
    # Answer the query
    answer = video_segment.select_answer(info, query, possible_answers)
    return answer"|tt1300851_90|"Is the trope ""Red Herring"", which means ""A clue that leads in the wrong direction."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt1300851.mp4|['yes', 'no']
