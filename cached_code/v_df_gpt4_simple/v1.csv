answer|groundtruth|id|trope|query|img_path|possible_answers|code|info|reason|compilation_error|runtime_error
NO EXECUTION|yes|tt0120586_0|Big Bad|"Is the trope ""Big Bad"", which means ""The character who is the direct cause of all of the bad happenings in a story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Big Bad
    # Definition: The character who is the direct cause of all of the bad happenings in a story.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify key characters and their actions.
    # 2. Character Analysis: Identify the character whose actions lead to negative outcomes throughout the video.
    # 3. Answer Selection: Determine if there is a single character responsible for the primary negative events, fitting the ""Big Bad"" trope.

    video_segment = VideoSegment(video, annotation)
    info = {}
    character_actions = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame and their actions
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            person_action = frame.simple_query(""What's he/she doing?"")
            if person_id not in character_actions:
                character_actions[person_id] = []
            character_actions[person_id].append(person_action)
    
    # Analyze the collected actions to determine if there's a single character causing negative outcomes
    for character_id, actions in character_actions.items():
        # Count negative actions
        negative_actions = [action for action in actions if ""destroy"" in action or ""harm"" in action]
        info[character_id] = {
            ""total_actions"": len(actions),
            ""negative_actions"": len(negative_actions),
            ""actions"": actions
        }
    
    # Determine if there is a ""Big Bad"" character
    big_bad_candidate = None
    for character_id, details in info.items():
        if details[""negative_actions""] > len(details[""actions""]) / 2:  # More than half actions are negative
            if big_bad_candidate is None or details[""negative_actions""] > info[big_bad_candidate][""negative_actions""]:
                big_bad_candidate = character_id
    
    if big_bad_candidate:
        answer = ""yes""
        reason = f""The character {big_bad_candidate} is responsible for most of the negative actions in the story.""
    else:
        answer = ""no""
        reason = ""There is no single character who is the direct cause of all the bad happenings in the story.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_1|Jerkass|"Is the trope ""Jerkass"", which means ""A character who is so completely obnoxious that it is unbelievable anyone would willingly interact with them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Jerkass
    # Definition: A character who is so completely obnoxious that it is unbelievable anyone would willingly interact with them.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their interactions.
    # 2. Character Analysis: Identify obnoxious behavior and reactions from other characters.
    # 3. Answer Selection: Use the collected data to determine if the ""Jerkass"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_interactions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        characters = frame.find(""person"")
        for character in characters:
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the character's behavior and others' reactions
            character_behavior = character.simple_query(""What's he/she doing?"")
            others_reaction = character.simple_query(""How are others reacting to him/her?"")

            if character_id not in info[""character_interactions""]:
                info[""character_interactions""][character_id] = []

            info[""character_interactions""][character_id].append({
                ""behavior"": character_behavior,
                ""reactions"": others_reaction
            })

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_2|Faux Affably Evil|"Is the trope ""Faux Affably Evil"", which means ""A villain whose politeness is an act that only serves to enhance their evil."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Faux Affably Evil
    # Definition: A villain whose politeness is an act that only serves to enhance their evil.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their interactions.
    # 2. Character Analysis: Identify the villain and analyze their behavior and dialogue for faux politeness.
    # 3. Answer Selection: Use the collected information to determine if the ""Faux Affably Evil"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_behaviors"": {},
        ""dialogues"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue

            # Query character's action and dialogue
            character_action = frame.simple_query(""What's he/she doing?"")
            character_dialogue = frame.simple_query(""What is he/she saying?"")

            # Store character behavior and dialogue
            if character_id not in info[""character_behaviors""]:
                info[""character_behaviors""][character_id] = []
            info[""character_behaviors""][character_id].append(character_action)

            if character_id not in info[""dialogues""]:
                info[""dialogues""][character_id] = []
            info[""dialogues""][character_id].append(character_dialogue)

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_3|Smug Snake|"Is the trope ""Smug Snake"", which means ""A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Smug Snake
    # Definition: A type of character (usually a villain) who tends to treat friends and enemies alike with equal disdain.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their interactions.
    # 2. Character Analysis: Identify the character traits and interactions to determine if any character fits the ""Smug Snake"" trope.
    # 3. Answer Selection: Use the collected information to determine if the trope is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_interactions"": {},
        ""character_traits"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        characters = frame.find(""person"")
        for character in characters:
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query character's interaction and traits
            interaction = frame.simple_query(""What is this character's interaction with others?"")
            traits = frame.simple_query(""Describe this character's traits."")
            if character_id not in info[""character_interactions""]:
                info[""character_interactions""][character_id] = []
            if character_id not in info[""character_traits""]:
                info[""character_traits""][character_id] = []
            info[""character_interactions""][character_id].append(interaction)
            info[""character_traits""][character_id].append(traits)

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_4|Abusive Parents|"Is the trope ""Abusive Parents"", which means ""This includes parents who are emotionally, verbally, physically, or mentally abusive, or who neglectfully allow their children to be abused 
by others if they don't abuse the child themselves"", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Abusive Parents
    # Definition: This includes parents who are emotionally, verbally, physically, or mentally abusive, or who neglectfully allow their children to be abused by others if they don't abuse the child themselves.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify interactions between parents and children.
    # 2. Behavior Analysis: Look for visual or dialog cues that indicate any form of abuse or neglect.
    # 3. Answer Selection: Use the collected information to determine if the ""Abusive Parents"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    abusive_behavior_detected = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all persons in the frame
        persons = frame.find(""person"")
        for person in persons:
            # Identify if the person is a parent or a child
            relationship_query = person.simple_query(""What is the relationship of this person to others in the scene?"")
            if 'parent' in relationship_query.lower() or 'child' in relationship_query.lower():
                # Check for any abusive behavior
                abuse_query = person.simple_query(""Is there any sign of abuse or neglect?"", to_yesno=True)
                if 'yes' in abuse_query.lower():
                    abusive_behavior_detected = True
                    # Collect evidence of abuse
                    description_of_abuse = person.simple_query(""Describe the abuse or neglect."")
                    info[f""Abuse detected in frame {i}""] = description_of_abuse

    # Determine if the trope is applicable based on collected evidence
    if abusive_behavior_detected:
        answer = 'yes'
        reason = ""Evidence of abusive behavior was detected in multiple frames.""
    else:
        answer = 'no'
        reason = ""No clear evidence of abusive behavior was found.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_5|Would Hurt a Child|"Is the trope ""Would Hurt a Child"", which means ""People that do hurt children, sometimes even kill them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Would Hurt a Child
    # Definition: This trope involves characters who harm children, showcasing their malevolence.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find interactions involving children.
    # 2. Event Observation: Detect any harmful actions directed towards children.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Would Hurt a Child"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    harmful_actions = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for the presence of children and any harmful actions
        children_present = frame.exists(""child"")
        if children_present:
            # Query about harmful actions in the frame
            harm_query = frame.simple_query(""Is there any harm being done to children?"", to_yesno=True)
            if ""yes"" in harm_query.lower():
                harmful_actions = True
                # Collect evidence of harmful actions
                description_of_harm = frame.simple_query(""Describe the harm being done to children."")
                info[f""Harmful action in frame {i}""] = description_of_harm

    # Determine if the trope is applicable based on the presence of harmful actions
    if harmful_actions:
        answer = ""yes""
        reason = ""There are instances of harm being done to children.""
    else:
        answer = ""no""
        reason = ""No harmful actions towards children were detected.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_6|Action Girl|"Is the trope ""Action Girl"", which means ""An Action Girl is a female badass who is tough and kicks butt."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Action Girl
    # Definition: An Action Girl is a female badass who is tough and kicks butt.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find female characters involved in action sequences.
    # 2. Character Analysis: Identify each female character and collect their actions.
    # 3. Answer Selection: Determine if any female character meets the criteria of being tough and kicking butt.
    
    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {}
    }
    
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Find all characters labeled as 'female'
        female_characters = frame.find(""female"")
        
        for female in female_characters:
            # Identify the character
            character_id = video_segment.face_identify(female)
            if character_id is None:
                continue
            
            # Query what the character is doing
            action_description = female.simple_query(""What's she doing?"")
            
            # Check if the action can be considered as 'tough' and 'kicking butt'
            if ""fight"" in action_description.lower() or ""action"" in action_description.lower():
                if character_id not in info[""character_actions""]:
                    info[""character_actions""][character_id] = []
                info[""character_actions""][character_id].append(action_description)
    
    # After collecting information, use it to determine the presence of the trope
    if any(actions for actions in info[""character_actions""].values()):
        answer = ""yes""
        reason = ""There are female characters who are involved in tough actions and kicking butt.""
    else:
        answer = ""no""
        reason = ""No female characters were involved in actions that could be considered tough or kicking butt.""
    
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_7|Reasonable Authority Figure|"Is the trope ""Reasonable Authority Figure"", which means ""Authirity that is open to heros' inasane ideas.  Often, they'll ask for proof and facts rather than follow baseless accusations, but even then, 
they'll usually humor the heroes and go check out their theories."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Reasonable Authority Figure
    # Definition: An authority figure in the narrative who is open to the protagonists' ideas, often requiring proof but willing to investigate their theories.
    # Thought Process:
    # 1. Frame Selection: Analyze frames where authority figures interact with protagonists or other key characters.
    # 2. Contextual Analysis: Look for dialogues or actions where the authority figure is responding to ideas or theories presented by protagonists.
    # 3. Answer Selection: Determine if the authority figure's behavior aligns with being reasonable and supportive of the protagonists' ideas.

    video_segment = VideoSegment(video, annotation)
    info = {}
    authority_figures = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Detect authority figures and their interactions
        for person in frame.find(""authority figure""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query about the interaction details
            interaction_query = ""What is the authority figure doing in response to the protagonist's ideas?""
            interaction_details = frame.simple_query(interaction_query)
            if person_id not in authority_figures:
                authority_figures.append(person_id)
            if person_id not in info:
                info[person_id] = []
            info[person_id].append({
                f""interaction in {i} frame"": interaction_details
            })

    # After collecting information, use it to determine the presence of the trope
    if any(""listening"" in interaction['interaction in {i} frame'].lower() or ""considering"" in interaction['interaction in {i} frame'].lower() for interactions in info.values() for interaction in interactions):
        answer = ""yes""
        reason = ""There are authority figures who are open to listening and considering the protagonists' ideas.""
    else:
        answer = ""no""
        reason = ""No authority figures were observed who were open to the protagonists' ideas.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_8|Papa Wolf|"Is the trope ""Papa Wolf"", which means ""Paternal instinct can transform a Bumbling Dad into an Action Dad. If someone threatens his kids they will soon wish 
they'd never come within a mile of them."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Papa Wolf
    # Definition: Paternal instinct can transform a Bumbling Dad into an Action Dad. If someone threatens his kids, they will soon wish they'd never come within a mile of them.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where a father figure is present and interacts with or protects his children.
    # 2. Action Analysis: Look for significant actions where the father figure takes decisive action to protect his children from a threat.
    # 3. Answer Selection: Use the collected information to determine if the ""Papa Wolf"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""father_actions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all persons in the frame
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query about the relationship and actions
            relationship_query = frame.simple_query(""What is the relationship of this person to others in the scene?"")
            action_query = frame.simple_query(""What is this person doing?"")
            # Check if the person is a father and is taking action to protect children
            if ""father"" in relationship_query.lower() and ""protect"" in action_query.lower():
                info[""father_actions""][f""frame {i}""] = {
                    ""relationship"": relationship_query,
                    ""action"": action_query
                }

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_9|Deadpan Snarker|"Is the trope ""Deadpan Snarker"", which means ""A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Deadpan Snarker
    # Definition: A character prone to gnomic, sarcastic, sometimes bitter, occasionally whimsical asides.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their dialogues.
    # 2. Dialogue Analysis: Look for characteristics of sarcasm, bitterness, or whimsical comments in dialogues.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Deadpan Snarker"" is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the dialogue of the character
            dialogue = frame.simple_query(""What is the character saying?"")
            # Check for sarcasm or whimsical elements in the dialogue
            is_sarcastic = frame.llm_query(f""Is the dialogue '{dialogue}' sarcastic?"", to_yesno=True)
            is_whimsical = frame.llm_query(f""Is the dialogue '{dialogue}' whimsical?"", to_yesno=True)
            # Collect information about the character and their dialogue
            if character_id not in info:
                info[character_id] = []
            info[character_id].append({
                ""frame"": i,
                ""dialogue"": dialogue,
                ""sarcastic"": is_sarcastic,
                ""whimsical"": is_whimsical
            })

    # After collecting information, use it to determine the presence of the trope
    sarcastic_or_whimsical_dialogues = any(
        any(d['sarcastic'] == 'yes' or d['whimsical'] == 'yes' for d in details)
        for details in info.values()
    )

    answer = ""yes"" if sarcastic_or_whimsical_dialogues else ""no""
    reason = ""Found sarcastic or whimsical dialogues"" if sarcastic_or_whimsical_dialogues else ""No sarcastic or whimsical dialogues found""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_10|Determinator|"Is the trope ""Determinator"", which means ""A character \ good or evil, male or female, young or old \ who never gives up. Ever. No matter what."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Determinator
    # Definition: A character, regardless of their moral alignment, gender, or age, who exhibits relentless persistence and never gives up under any circumstances.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to observe the character's actions and responses to challenges.
    # 2. Character Analysis: Identify key characters and track their actions and reactions throughout the video.
    # 3. Answer Selection: Determine if any character fits the ""Determinator"" trope based on their persistence and actions in the face of adversity.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_persistence"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the character's action and context
            character_action = frame.simple_query(""What is the character doing?"")
            character_challenge = frame.simple_query(""Is the character facing any challenge?"", to_yesno=True)

            # Track character's persistence and challenges faced
            if character_id not in info[""character_persistence""]:
                info[""character_persistence""][character_id] = {
                    ""actions"": [],
                    ""challenges"": 0,
                    ""persistent_actions"": 0
                }

            info[""character_persistence""][character_id][""actions""].append(character_action)
            if ""yes"" in character_challenge.lower():
                info[""character_persistence""][character_id][""challenges""] += 1
                # Check if the character continues despite challenges
                continues_action = frame.simple_query(""Does the character continue their action despite the challenge?"", to_yesno=True)
                if ""yes"" in continues_action.lower():
                    info[""character_persistence""][character_id][""persistent_actions""] += 1

    # Determine if any character fits the ""Determinator"" trope
    determinator_found = False
    for character_id, data in info[""character_persistence""].items():
        if data[""challenges""] > 0 and data[""persistent_actions""] == data[""challenges""]:
            determinator_found = True
            break

    answer = ""yes"" if determinator_found else ""no""
    reason = ""A character consistently showed persistence in the face of challenges."" if determinator_found else ""No character displayed the required level of persistence.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_11|Only Sane Man|"Is the trope ""Only Sane Man"", which means ""When there is a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only 
one who, well, isn't."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Only Sane Man
    # Definition: In a group of characters who are all just totally weird, either in general or in a particular scenario, the Only Sane Man is the only one who isn't.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify groups of characters and their behaviors.
    # 2. Character Analysis: Identify the behavior of each character in the group to determine if they are acting weirdly.
    # 3. Sanity Check: Identify if there is one character who is noticeably less weird or acting normally compared to others.
    # 4. Answer Selection: Use the collected information to determine if the ""Only Sane Man"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_behaviors"": {}
    }
    sane_character_found = False
    for i, frame in enumerate(video_segment.frame_iterator()):
        characters = frame.find(""person"")
        character_behaviors = []
        for character in characters:
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            character_behavior = character.simple_query(""What's he/she doing?"")
            character_behaviors.append((character_id, character_behavior))
            if character_id not in info[""character_behaviors""]:
                info[""character_behaviors""][character_id] = []
            info[""character_behaviors""][character_id].append(character_behavior)
        
        # Check if there's exactly one character behaving normally
        weird_behaviors = [behavior for _, behavior in character_behaviors if ""weird"" in behavior or ""strange"" in behavior]
        normal_behaviors = [behavior for _, behavior in character_behaviors if ""weird"" not in behavior and ""strange"" not in behavior]
        
        if len(weird_behaviors) > 0 and len(normal_behaviors) == 1:
            sane_character_found = True

    # After collecting information, use it to determine the presence of the trope
    if sane_character_found:
        answer = ""yes""
        reason = ""There is one character who acts normally while others do not, fitting the 'Only Sane Man' trope.""
    else:
        answer = ""no""
        reason = ""No single character consistently acts as the 'Only Sane Man' among a group of weird characters.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_12|Anti-Hero|"Is the trope ""Anti-Hero"", which means ""An antihero is a protagonist who has the opposite of most of the traditional attributes of a hero."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Anti-Hero
    # Definition: An antihero is a protagonist who has the opposite of most of the traditional attributes of a hero.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify the protagonist and their actions.
    # 2. Character Analysis: Determine if the protagonist exhibits traits opposite to traditional heroic traits.
    # 3. Answer Selection: Use the collected information to decide if the ""Anti-Hero"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {},
        ""character_traits"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query character actions and traits
            character_action = frame.simple_query(""What is the character doing?"")
            character_trait = frame.simple_query(""Describe the character's traits."")

            if character_id not in info[""character_actions""]:
                info[""character_actions""][character_id] = []
            if character_id not in info[""character_traits""]:
                info[""character_traits""][character_id] = []

            info[""character_actions""][character_id].append(character_action)
            info[""character_traits""][character_id].append(character_trait)

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_13|Asshole Victim|"Is the trope ""Asshole Victim"", which means ""When the victim is a bad guy."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Asshole Victim
    # Definition: A narrative trope where the victim of a crime or misdeed is someone who had it coming because they were themselves morally dubious or outright villainous.
    # Thought Process:
    # 1. Frame Selection: This trope involves identifying both the 'victim' and the act leading to their victimhood, suggesting a need for comprehensive analysis throughout the video.
    # 2. Character Analysis: Identify each character and collect their actions or character traits
    # 3. Answer Selection: Using the collected data, decide whether the ""Asshole Victim"" trope is present.
    video_segment = VideoSegment(video, annotation)
    # Initialize a dictionary to store information collected during analysis
    info = {
        ""captions"": {},
        ""character_behaviors"": {}
    }
    for i, frame in enumerate(video_segment.frame_iterator()):
        # collect background story from caption of frame
        caption = frame.simple_query(""What's happening in the scene?"")
        info[""captions""][f""{i} frame""] = caption
        # identify person in frame
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)    
            if person_id is None:
                continue
            # get description of person
            person_description = person.simple_query(""What's his/her appearance characteristic? Describe in 10 words"")
            # track character behavior 
            person_behavior_in_frame = frame.simple_query(f""What's action of person with appearance '{person_description}'"")
            if person_id not in info[""character_behaviors""]:
                info[""character_behaviors""][person_id] = {}
            info[""character_behaviors""][person_id].update({
                f""action in {i} frame"": person_behavior_in_frame
            })
    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_14|Jerk with a Heart of Gold|"Is the trope ""Jerk with a Heart of Gold"", which means ""A person you would expect to be a big Jerkass has some redeeming qualities behind their tough demeanor."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Jerk with a Heart of Gold
    # Definition: A person you would expect to be a big Jerkass has some redeeming qualities behind their tough demeanor.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their actions.
    # 2. Character Analysis: Identify key characters and collect their actions or character traits.
    # 3. Answer Selection: Using the collected data, decide whether the ""Jerk with a Heart of Gold"" trope is present.
    
    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {},
        ""redeeming_qualities"": {}
    }
    
    for i, frame in enumerate(video_segment.frame_iterator()):
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Get description of person's actions
            person_action = frame.simple_query(""What's he/she doing?"")
            person_emotion = frame.simple_query(""What's his/her emotion?"")
            
            # Track character behavior and emotions
            if person_id not in info[""character_actions""]:
                info[""character_actions""][person_id] = []
            info[""character_actions""][person_id].append(person_action)
            
            # Check for redeeming qualities if the character appears tough or negative
            if ""angry"" in person_emotion or ""aggressive"" in person_action:
                redeeming_action = frame.simple_query(""Is there any kind action or positive emotion shown by this person?"", to_yesno=True)
                if redeeming_action == ""yes"":
                    if person_id not in info[""redeeming_qualities""]:
                        info[""redeeming_qualities""][person_id] = []
                    info[""redeeming_qualities""][person_id].append(frame.simple_query(""Describe the kind action or positive emotion.""))
    
    # After collecting information, use it to determine the presence of the trope
    has_jerk_with_heart = any(info[""redeeming_qualities""].values())
    answer = ""yes"" if has_jerk_with_heart else ""no""
    reason = ""Character shows redeeming qualities despite tough demeanor."" if has_jerk_with_heart else ""No redeeming qualities found for tough characters.""
    
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_15|Even Evil Has Standards|"Is the trope ""Even Evil Has Standards"", which means ""Keep a villain safely on the ""still sympathetic"" side of the Moral Event Horizon; give him something that he simply will not do."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Even Evil Has Standards
    # Definition: A narrative trope where a villain, despite their malevolence, has moral limits they will not cross.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to find instances where the villain is present.
    # 2. Character Analysis: Identify actions and decisions of the villain that might indicate moral boundaries.
    # 3. Answer Selection: Use the collected data to determine if the trope ""Even Evil Has Standards"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    villain_actions = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters classified as 'villain'
        for villain in frame.find(""villain""):
            villain_id = video_segment.face_identify(villain)
            if villain_id is None:
                continue
            # Query about the villain's actions in the frame
            action_description = frame.simple_query(""What is the villain doing?"")
            # Check if the action might indicate a moral boundary
            is_moral_action = frame.llm_query(f""Does the action '{action_description}' suggest a moral boundary?"", to_yesno=True)
            if 'yes' in is_moral_action.lower():
                moral_action_detail = frame.simple_query(""Describe the moral action taken by the villain."")
                villain_actions.append(moral_action_detail)
                info[f""Villain moral action in frame {i}""] = moral_action_detail

    # After collecting information, use it to determine the presence of the trope
    if villain_actions:
        answer = ""yes""
        reason = ""The villain shows moral boundaries in actions such as: "" + "", "".join(villain_actions)
    else:
        answer = ""no""
        reason = ""No evidence of moral boundaries was observed in the villain's actions.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_16|Affably Evil|"Is the trope ""Affably Evil"", which means ""Villains that are not too bad. There is absolutely nothing separating them from being normal, polite people except for the fact that they want 
to take over the world."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Affably Evil
    # Definition: Villains that are not too bad. There is absolutely nothing separating them from being normal, polite people except for the fact that they want to take over the world.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters that could be potential villains.
    # 2. Character Analysis: For each identified character, analyze their actions and dialogues to determine if they exhibit traits of being polite and normal but with villainous goals.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Affably Evil"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    villainous_actions = [""take over the world"", ""scheme"", ""plot""]

    for i, frame in enumerate(video_segment.frame_iterator()):
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query about the character's actions and dialogue
            character_action = frame.simple_query(""What's he/she doing?"")
            character_dialogue = frame.simple_query(""What's he/she saying?"")

            # Check if actions or dialogue match the villainous but polite profile
            if any(action in character_action.lower() for action in villainous_actions):
                info[character_id] = {
                    ""actions"": character_action,
                    ""dialogue"": character_dialogue,
                    ""frame"": i
                }

    # Determine if any character fits the ""Affably Evil"" trope
    for character_id, details in info.items():
        if ""polite"" in details[""dialogue""].lower() and any(action in details[""actions""].lower() for action in villainous_actions):
            answer, reason = ""yes"", f""Character {character_id} in frame {details['frame']} shows both politeness and villainous intentions.""
            return answer, reason, info

    answer, reason = ""no"", ""No character fits the 'Affably Evil' trope based on the analyzed frames.""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_17|Too Dumb to Live|"Is the trope ""Too Dumb to Live"", which means ""People who are so stupid that they simply do not deserve to survive."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Too Dumb to Live
    # Definition: A trope involving characters who display such a lack of common sense or self-preservation that it strains credibility and they often meet untimely ends as a result.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify any character making obviously poor decisions that could lead to dangerous outcomes.
    # 2. Character Analysis: Identify characters and their actions, especially focusing on those that are unnecessarily risky or illogical given the context.
    # 3. Answer Selection: Use the collected data to determine if the ""Too Dumb to Live"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query what the character is doing in the frame
            action_description = frame.simple_query(""What is the character doing?"")
            # Check if the action is considered risky or illogical
            is_risky = frame.llm_query(f""Is the action '{action_description}' considered risky or illogical?"", to_yesno=True)
            if ""yes"" in is_risky.lower():
                if character_id not in info[""character_actions""]:
                    info[""character_actions""][character_id] = []
                info[""character_actions""][character_id].append(action_description)

    # After collecting information, use it to determine the presence of the trope
    if any(info[""character_actions""].values()):  # If any character has performed a risky/illogical action
        answer = ""yes""
        reason = ""There are characters whose actions are considered too risky or illogical, fitting the 'Too Dumb to Live' trope.""
    else:
        answer = ""no""
        reason = ""No character actions were identified that fit the 'Too Dumb to Live' trope.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_18|Butt-Monkey|"Is the trope ""Butt-Monkey"", which means ""The character who is always the butt of the demeaning joke or the ""put them through hell"" plotline."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Butt-Monkey
    # Definition: The character who is always the butt of the demeaning joke or the ""put them through hell"" plotline.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their experiences.
    # 2. Character Analysis: Identify characters who repeatedly experience negative events or jokes at their expense.
    # 3. Answer Selection: Use the collected data to determine if the ""Butt-Monkey"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_events"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query what is happening to the character
            event_description = frame.simple_query(""What is happening to this person?"")
            # Track events related to each character
            if character_id not in info[""character_events""]:
                info[""character_events""][character_id] = []
            info[""character_events""][character_id].append(event_description)

    # After collecting information, use it to determine the presence of the trope
    # Check if any character has a significantly high number of negative events
    for character_id, events in info[""character_events""].items():
        negative_events = [event for event in events if ""embarrass"" in event or ""humiliate"" in event or ""fail"" in event]
        if len(negative_events) > len(events) / 2:  # More than half of the events are negative
            answer, reason = ""yes"", f""The character {character_id} is frequently humiliated or put through troubling situations.""
            return answer, reason, info

    answer, reason = ""no"", ""No character consistently experiences demeaning jokes or negative plotlines to a significant extent.""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_19|Ax-Crazy|"Is the trope ""Ax-Crazy"", which means ""An ""ax-crazy"" character is someone who is psychologically unstable and presents a clear and immediate danger to others."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Ax-Crazy
    # Definition: An ""ax-crazy"" character is someone who is psychologically unstable and presents a clear and immediate danger to others.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify any character that might be displaying extreme psychological instability or dangerous behavior.
    # 2. Character Analysis: For each identified character, analyze their actions and interactions with others to assess the level of danger they present.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Ax-Crazy"" is applicable to any character in the video.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the character's actions and emotional state
            character_action = frame.simple_query(""What is the character doing?"")
            character_emotion = frame.simple_query(""What is the character's emotional state?"")
            # Record the character's actions and emotions
            if character_id not in info[""character_actions""]:
                info[""character_actions""][character_id] = []
            info[""character_actions""][character_id].append({
                ""frame"": i,
                ""action"": character_action,
                ""emotion"": character_emotion
            })

    # Analyze the collected information to determine if any character fits the ""Ax-Crazy"" trope
    for character_id, actions in info[""character_actions""].items():
        for action_info in actions:
            if ""danger"" in action_info[""action""].lower() or ""unstable"" in action_info[""emotion""].lower():
                answer, reason = ""yes"", f""Character {character_id} shows signs of being 'Ax-Crazy' in frame {action_info['frame']}.""
                return answer, reason, info

    answer, reason = ""no"", ""No character fits the 'Ax-Crazy' trope based on the analyzed frames.""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_20|Adorkable|"Is the trope ""Adorkable"", which means ""An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character 
an endearing vulnerability."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Adorkable
    # Definition: An adorkable character might be socially inept, shy or clumsy. However, rather than making them an outcast, these quirks give the character an endearing vulnerability.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their behaviors.
    # 2. Character Analysis: Identify traits of being socially inept, shy, or clumsy.
    # 3. Answer Selection: Determine if these traits contribute positively to the character's charm and endearment, making them adorkable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    character_traits = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query about the character's social behavior and emotional expression
            social_behavior = frame.simple_query(""What is the character doing?"", to_yesno=False)
            emotional_expression = frame.simple_query(""What is the character's emotional expression?"", to_yesno=False)

            # Collecting data on each character
            if person_id not in character_traits:
                character_traits[person_id] = {
                    ""social_behaviors"": [],
                    ""emotional_expressions"": []
                }
            character_traits[person_id][""social_behaviors""].append(social_behavior)
            character_traits[person_id][""emotional_expressions""].append(emotional_expression)

    # Analyze collected data to determine if any character fits the 'Adorkable' trope
    for person_id, traits in character_traits.items():
        social_clumsiness = any(""awkward"" in behavior or ""clumsy"" in behavior for behavior in traits[""social_behaviors""])
        shyness = any(""shy"" in expression or ""timid"" in expression for expression in traits[""emotional_expressions""])
        endearing = any(""endearing"" in expression or ""charming"" in expression for expression in traits[""emotional_expressions""])

        if social_clumsiness and shyness and endearing:
            info[person_id] = {
                ""social_behaviors"": traits[""social_behaviors""],
                ""emotional_expressions"": traits[""emotional_expressions""]
            }

    # Decide if the trope is relevant based on the presence of adorkable characters
    if info:
        answer, reason = ""yes"", ""There are characters that exhibit socially awkward, shy, and endearing traits, fitting the 'Adorkable' trope.""
    else:
        answer, reason = ""no"", ""No characters were found that fit the 'Adorkable' trope based on the analyzed frames.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_21|Berserk Button|"Is the trope ""Berserk Button"", which means ""Some characters always get enraged when given a certain, minor trigger."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Berserk Button
    # Definition: Some characters always get enraged when given a certain, minor trigger.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify characters and their reactions to specific triggers.
    # 2. Character Reaction Analysis: Detect and analyze the reactions of characters to minor triggers to determine if they get enraged.
    # 3. Answer Selection: Use the collected information to determine if the ""Berserk Button"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    character_reactions = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue

            # Query the character's action and emotion
            action = character.simple_query(""What's he/she doing?"")
            emotion = character.simple_query(""What's his/her emotion?"")

            # Check if the action or emotion suggests a reaction to a minor trigger
            if ""enraged"" in emotion.lower() or ""angry"" in emotion.lower():
                trigger_query = ""What caused the anger or rage?""
                trigger = character.simple_query(trigger_query)
                if character_id not in character_reactions:
                    character_reactions[character_id] = []
                character_reactions[character_id].append((trigger, action, emotion))

    # Store the collected data in the info dictionary
    info['character_reactions'] = character_reactions

    # Determine if the Berserk Button trope is present
    for reactions in character_reactions.values():
        for trigger, action, emotion in reactions:
            if ""minor"" in trigger.lower():
                answer, reason = ""yes"", f""Character reacts with {emotion} to a minor trigger: {trigger}""
                return answer, reason, info

    answer, reason = ""no"", ""No character reactions match the Berserk Button trope criteria.""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_22|Ms. Fanservice|"Is the trope ""Ms. Fanservice"", which means ""A female character who provides a significant amount of Fanservice (generally for males), ranging from simple revealing of cleavage, midriff, 
shoulders or legs, to shots of her curves, hips or derriere (even when covered)."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Ms. Fanservice
    # Definition: A female character who provides a significant amount of Fanservice, generally for males, ranging from simple revealing of cleavage, midriff, shoulders or legs, to shots of her curves, hips or derriere, even when covered.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify any female character.
    # 2. Visual Analysis: For each identified female character, analyze the attire and posture to determine if it aligns with the trope's definition.
    # 3. Contextual Analysis: Consider the context in which the character appears to determine if the portrayal is intended to provide Fanservice.
    # 4. Answer Selection: Use the collected information to determine if the trope ""Ms. Fanservice"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    fanservice_indicators = [""cleavage"", ""midriff"", ""shoulders"", ""legs"", ""curves"", ""hips"", ""derriere""]

    for i, frame in enumerate(video_segment.frame_iterator()):
        for character in frame.find(""female""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query about the attire and posture of the character
            attire_description = character.simple_query(""Describe the attire of the character."")
            posture_description = character.simple_query(""Describe the posture of the character."")

            # Check for fanservice indicators
            fanservice_present = any(indicator in attire_description.lower() or indicator in posture_description.lower() for indicator in fanservice_indicators)
            
            if fanservice_present:
                info[f""Fanservice indicator in frame {i}""] = {
                    ""attire"": attire_description,
                    ""posture"": posture_description
                }

    # Determine if the trope is applicable based on the collected information
    if info:
        answer, reason = ""yes"", f""Fanservice elements detected in multiple frames: {info}""
    else:
        answer, reason = ""no"", ""No significant fanservice elements were detected.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_23|The Alcoholic|"Is the trope ""The Alcoholic"", which means ""This person likes their liquor, and in large amounts."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: The Alcoholic
    # Definition: This person likes their liquor, and in large amounts.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find characters consuming alcohol or showing signs of heavy drinking.
    # 2. Character Analysis: Identify characters and collect their actions related to alcohol consumption.
    # 3. Answer Selection: Use the collected data to determine if the trope ""The Alcoholic"" is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query if the person is consuming alcohol
            alcohol_query = frame.simple_query(""Is the person consuming alcohol?"", to_yesno=True)
            if 'yes' in alcohol_query.lower():
                # Collect evidence of alcohol consumption
                alcohol_detail = frame.simple_query(""Describe the alcohol consumption."")
                if person_id not in info[""character_actions""]:
                    info[""character_actions""][person_id] = []
                info[""character_actions""][person_id].append(alcohol_detail)

    # After collecting information, use it to determine the presence of the trope
    if any(info[""character_actions""].values()):  # If any character has actions related to alcohol consumption
        answer = ""yes""
        reason = ""There are characters shown consuming alcohol in large amounts.""
    else:
        answer = ""no""
        reason = ""No significant alcohol consumption was observed.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_24|Disappeared Dad|"Is the trope ""Disappeared Dad"", which means ""The father of a character or characters is missing or absent."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Disappeared Dad
    # Definition: The father of a character or characters is missing or absent.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find any mention or appearance of a father figure.
    # 2. Contextual Analysis: Determine if the father figure is mentioned as missing, absent, or not present in significant events.
    # 3. Answer Selection: Use the collected information to determine if the ""Disappeared Dad"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    father_present = False
    father_absent_mentioned = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for the presence of a father figure
        if frame.exists(""father""):
            father_present = True
            action = frame.simple_query(""What is the father doing?"")
            info[f""Father action in frame {i}""] = action

        # Check if there's any dialogue or context suggesting the father is missing or absent
        absence_query = frame.simple_query(""Is the father mentioned as missing or absent?"", to_yesno=True)
        if ""yes"" in absence_query.lower():
            father_absent_mentioned = True
            context = frame.simple_query(""What is the context of the father's absence?"")
            info[f""Father absence context in frame {i}""] = context

    # Determine if the trope applies
    if not father_present and father_absent_mentioned:
        answer = ""yes""
        reason = ""The father is mentioned as missing or absent, and no father figure appears throughout the video.""
    else:
        answer = ""no""
        reason = ""The father figure appears in the video or is not mentioned as absent.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_25|Would Hit a Girl|"Is the trope ""Would Hit a Girl"", which means ""A guy (good or evil) has no problems with violence against women."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Would Hit a Girl
    # Definition: A guy (good or evil) has no problems with violence against women.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances of violence or aggressive interactions.
    # 2. Character Analysis: Identify characters involved in these interactions and their genders.
    # 3. Contextual Analysis: Determine the context of the interaction, whether it's aggressive or violent.
    # 4. Answer Selection: Use the collected information to decide if the trope ""Would Hit a Girl"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for any violent interactions in the frame
        violence_query = frame.simple_query(""Is there any violent interaction?"", to_yesno=True)
        if 'yes' in violence_query.lower():
            # Identify characters involved in the violence
            for person in frame.find(""person""):
                person_id = video_segment.face_identify(person)
                if person_id is None:
                    continue
                # Get gender and action of the person
                person_gender = person.simple_query(""What is the gender of the person?"")
                person_action = person.simple_query(""What is the person doing?"")
                # Store information about violent interactions involving women
                if person_gender.lower() in ['female', 'woman', 'girl']:
                    info[f""Violence involving {person_gender} in frame {i}""] = person_action

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_26|Oh, Crap!|"Is the trope ""Oh, Crap!"", which means ""The moment at which a character realizes that something really, REALLY bad is about to happen."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Oh, Crap!
    # Definition: The moment at which a character realizes that something really, REALLY bad is about to happen.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect sudden changes in character expressions or situations indicating a realization of impending doom.
    # 2. Emotional and Contextual Analysis: Look for visual cues such as facial expressions of shock, fear, or sudden gestures that align with the trope.
    # 3. Answer Selection: Use the collected information to determine if the ""Oh, Crap!"" moment is present in the video.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for sudden changes in expressions or context that might indicate an ""Oh, Crap!"" moment
        expression_query = frame.simple_query(""Is there a sudden change in any character's expression?"", to_yesno=True)
        context_query = frame.simple_query(""Is there a sudden change in the situation?"", to_yesno=True)

        if ""yes"" in expression_query.lower() or ""yes"" in context_query.lower():
            # Capture the frame details and the nature of the expression or situation change
            expression_detail = frame.simple_query(""Describe the change in expression."")
            context_detail = frame.simple_query(""Describe the change in the situation."")
            info[f""Expression change at frame {i}""] = expression_detail
            info[f""Situation change at frame {i}""] = context_detail

    # Use the collected information to answer the query
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_27|Driven to Suicide|"Is the trope ""Driven to Suicide"", which means ""Whatever the reason, a character may be driven to commit suicide."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Driven to Suicide
    # Definition: A narrative trope where a character is driven to commit suicide due to various reasons.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect any signs of distress or suicidal tendencies.
    # 2. Emotional and Contextual Analysis: Look for visual cues of extreme sadness, hopelessness, or direct actions indicating suicidal intent.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Driven to Suicide"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}

    # Analyze frames for signs of distress or suicidal tendencies
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for signs of extreme emotional distress
        distress_query = frame.simple_query(""Is there any sign of extreme sadness or distress?"", to_yesno=True)
        suicidal_intent_query = frame.simple_query(""Is there any indication of suicidal intent?"", to_yesno=True)

        if ""yes"" in distress_query.lower() or ""yes"" in suicidal_intent_query.lower():
            # Collect information about the context and the character's emotional state
            context_description = frame.simple_query(""Describe the context and emotional state of the character."")
            info[f""Frame {i} - Distress""] = distress_query
            info[f""Frame {i} - Suicidal Intent""] = suicidal_intent_query
            info[f""Frame {i} - Context""] = context_description

    # Use the collected information to answer the query
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_28|Adult Fear|"Is the trope ""Adult Fear"", which means ""Things that mature, well-adjusted adults generally are concerned about, as opposed to supernatural fears."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Adult Fear
    # Definition: Concerns that mature, well-adjusted adults have, as opposed to supernatural or fantastical fears.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to identify scenes that might depict real-life adult concerns (e.g., safety of children, financial stability, health issues).
    # 2. Contextual Analysis: Look for dialogues, actions, or events that represent typical adult fears.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Adult Fear"" is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {}
    adult_fears = [""child safety"", ""health"", ""financial security"", ""job stability"", ""relationship issues""]

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query the frame for any content related to typical adult fears
        frame_content = frame.simple_query(""What is happening in the scene?"")
        for fear in adult_fears:
            if fear in frame_content.lower():
                info[f""Frame {i}""] = frame_content
                break

    # If any frame contains content related to adult fears, consider the trope relevant
    if info:
        answer = ""yes""
        reason = ""The video contains scenes depicting typical adult concerns such as child safety, health, and financial security.""
    else:
        answer = ""no""
        reason = ""The video does not contain scenes that depict typical adult concerns.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_29|Not So Different|"Is the trope ""Not So Different"", which means ""When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more 
than the other character would want to believe."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Not So Different
    # Definition: When one character in a pair (who'd otherwise be different and/or unrelated) discovers that they actually have some things in common, more than the other character would want to believe.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find interactions between two main characters.
    # 2. Character Analysis: Identify and analyze the dialogue and actions of the characters to find similarities they acknowledge.
    # 3. Answer Selection: Use the collected information to determine if the ""Not So Different"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}

    # Iterate through each frame to analyze character interactions
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Find all characters in the frame
        characters = frame.find(""person"")
        if len(characters) < 2:
            continue  # Need at least two characters to compare

        # Collect dialogues and actions for each character
        for character in characters:
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue

            # Query about the character's dialogue and actions
            dialogue = character.simple_query(""What is the character saying?"")
            action = character.simple_query(""What is the character doing?"")

            # Store information in the info dictionary
            if character_id not in info:
                info[character_id] = {
                    ""dialogues"": [],
                    ""actions"": []
                }
            info[character_id][""dialogues""].append(dialogue)
            info[character_id][""actions""].append(action)

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_30|Heroic BSoD|"Is the trope ""Heroic BSoD"", which means ""A stunning revelation or horrible event affects a character or someone they care deeply about, leaving them shocked to the point of mentally
 shutting down for a while."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Heroic BSoD
    # Definition: A stunning revelation or horrible event affects a character or someone they care deeply about, leaving them shocked to the point of mentally shutting down for a while.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect any significant emotional or traumatic events.
    # 2. Character Analysis: Identify characters and observe their reactions to events, particularly looking for signs of shock or mental shutdown.
    # 3. Answer Selection: Use the collected information to determine if the ""Heroic BSoD"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    character_responses = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Detect significant events that could potentially lead to a Heroic BSoD
        event_description = frame.simple_query(""Describe any significant event happening in this frame."")
        characters = frame.find(""person"")
        for character in characters:
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Check for character's emotional response
            emotional_state = character.simple_query(""What is the character's emotional state?"")
            if emotional_state.lower() in [""shocked"", ""stunned"", ""overwhelmed""]:
                if character_id not in character_responses:
                    character_responses[character_id] = []
                character_responses[character_id].append(emotional_state)
                info[f""Significant event at frame {i}""] = event_description
                info[f""{character_id} response at frame {i}""] = emotional_state

    # Determine if any character's response aligns with the Heroic BSoD trope
    for character_id, responses in character_responses.items():
        if any(state in [""shocked"", ""stunned"", ""overwhelmed""] for state in responses):
            answer, reason = ""yes"", f""Character {character_id} exhibited a Heroic BSoD response.""
            return answer, reason, info

    answer, reason = ""no"", ""No character exhibited a Heroic BSoD response.""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_31|"Big \""NO!\"""|"Is the trope ""Big \""NO!\"""", which means ""The moment when a character realizes that something awful has happened, or notices that something awful is about to happen, and screams 
""NOOOOOOOOOOOOOOO!"" "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Big ""NO!""
    # Definition: The moment when a character realizes that something awful has happened, or notices that something awful is about to happen, and screams ""NOOOOOOOOOOOOOOO!""
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential emotional outbursts or reactions to negative events.
    # 2. Emotional and Contextual Analysis: Look for visual and audio cues indicating a dramatic reaction, specifically the screaming of ""NO!"" in a context of despair or realization of a negative event.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Big 'NO!'"" is present in the video.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for any dramatic emotional outburst
        emotional_outburst = frame.simple_query(""Is there a dramatic emotional outburst?"", to_yesno=True)
        if ""yes"" in emotional_outburst.lower():
            # Further check if the outburst includes the specific scream ""NO!""
            specific_outburst = frame.simple_query(""Is the outburst a loud scream of 'NO!'?"", to_yesno=True)
            if ""yes"" in specific_outburst.lower():
                context = frame.simple_query(""What is happening in the scene that causes the scream?"")
                info[f""Dramatic NO at frame {i}""] = context

    # After collecting information, use it to determine the presence of the trope
    if info:
        answer, reason = video_segment.select_answer(info, query, possible_answers)
    else:
        answer, reason = ""no"", ""No dramatic 'NO!' outburst was detected in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_32|Eye Scream|"Is the trope ""Eye Scream"", which means ""When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the 
invasion of the eye sockets by a foreign body."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Eye Scream
    # Definition: When the creator of a work takes advantage of our Primal Fear of having something utterly horrible happen to our eyes, usually involving the invasion of the eye sockets by a foreign body.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential visual cues that might indicate an ""Eye Scream"" event.
    # 2. Event Observation: Look for scenes where characters experience or react to eye-related trauma.
    # 3. Answer Selection: Use the collected information to determine if the trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    eye_scream_detected = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for specific eye-related trauma or fear expressions
        eye_trauma_query = frame.simple_query(""Is there any eye-related trauma or horror?"", to_yesno=True)
        if ""yes"" in eye_trauma_query.lower():
            # Collect more detailed information about the event
            detailed_description = frame.simple_query(""Describe the eye-related trauma or horror event."")
            info[f""Eye trauma event in frame {i}""] = detailed_description
            eye_scream_detected = True

    # Determine if the trope ""Eye Scream"" is relevant based on the collected information
    if eye_scream_detected:
        answer = ""yes""
        reason = ""The video contains scenes of eye-related trauma or horror, aligning with the 'Eye Scream' trope.""
    else:
        answer = ""no""
        reason = ""No eye-related trauma or horror scenes were detected in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_33|Gory Discretion Shot|"Is the trope ""Gory Discretion Shot"", which means ""Blood or brains are seen splattering against a wall and the rest is left to the imagination."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Gory Discretion Shot
    # Definition: A narrative technique where the most violent or gory part of a scene is left to the viewer's imagination, often by cutting away from the scene or showing the aftermath instead of the act itself.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect any signs of violence or its immediate aftermath.
    # 2. Contextual Analysis: Look for visual cues that suggest a violent event has occurred without showing the actual act, such as blood splatters, weapons, expressions of horror, etc.
    # 3. Answer Selection: Use the collected information to determine if the ""Gory Discretion Shot"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for visual cues of violence or aftermath
        violence_query = frame.simple_query(""Is there any sign of violence?"", to_yesno=True)
        aftermath_query = frame.simple_query(""Is there any sign of aftermath of violence?"", to_yesno=True)

        if ""yes"" in violence_query.lower() or ""yes"" in aftermath_query.lower():
            # Collect details about the violence or aftermath
            details = frame.simple_query(""Describe the signs of violence or its aftermath."")
            info[f""Details at frame {i}""] = details

    # Determine if the trope is applicable based on the information collected
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_34|Impaled with Extreme Prejudice|"Is the trope ""Impaled with Extreme Prejudice"", which means "" When someone gets stabbed in a really extreme way.."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Impaled with Extreme Prejudice
    # Definition: When someone gets stabbed in a really extreme way.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances of extreme stabbing.
    # 2. Contextual Analysis: Look for visual cues of extreme violence, focusing on the act of stabbing.
    # 3. Answer Selection: Use the collected information to determine if the trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    extreme_stabbing_found = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query if there is an extreme stabbing event in the frame
        stabbing_query = frame.simple_query(""Is there an extreme stabbing event in this frame?"", to_yesno=True)
        if ""yes"" in stabbing_query.lower():
            # Collect details about the event
            event_description = frame.simple_query(""Describe the stabbing event."")
            info[f""Extreme stabbing event in frame {i}""] = event_description
            extreme_stabbing_found = True

    # Determine if the trope is relevant based on the collected information
    if extreme_stabbing_found:
        answer = ""yes""
        reason = ""There is at least one frame depicting an extreme stabbing event.""
    else:
        answer = ""no""
        reason = ""No extreme stabbing events were found in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_35|Off with His Head!|"Is the trope ""Off with His Head!"", which means ""When someone is going to get his head chopped off."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Off with His Head!
    # Definition: A narrative trope where a character is executed by decapitation.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find any scenes of execution or decapitation.
    # 2. Contextual Analysis: Look for visual cues such as a guillotine, axe, or any other execution tools, and the act of decapitation.
    # 3. Answer Selection: Use the collected information to determine if the ""Off with His Head!"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    execution_found = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for visual cues of execution tools or acts
        execution_tools_query = frame.simple_query(""Are there any execution tools like a guillotine or axe visible?"", to_yesno=True)
        decapitation_act_query = frame.simple_query(""Is there an act of decapitation occurring?"", to_yesno=True)

        if ""yes"" in execution_tools_query.lower() or ""yes"" in decapitation_act_query.lower():
            execution_found = True
            # Collect details about the scene
            scene_description = frame.simple_query(""Describe the scene with the execution tools or act."")
            info[f""Execution scene at frame {i}""] = scene_description

    # Determine if the trope is relevant based on the collected information
    if execution_found:
        answer = ""yes""
        reason = ""The trope 'Off with His Head!' is relevant as scenes of execution by decapitation were found.""
    else:
        answer = ""no""
        reason = ""The trope 'Off with His Head!' is not relevant as no scenes of execution by decapitation were detected.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_36|Disney Villain Death|"Is the trope ""Disney Villain Death"", which means ""Villains exit the film by falling off or out of things."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Disney Villain Death
    # Definition: Villains exit the film by falling off or out of things.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for scenes involving a fall, especially focusing on characters identified as villains.
    # 2. Character Analysis: Identify characters and determine if they are villains by their actions and roles in the narrative.
    # 3. Event Observation: Detect events of falling from significant heights or out of structures.
    # 4. Answer Selection: Use the collected information to determine if the trope ""Disney Villain Death"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    villain_fall_detected = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters and check if any are villains
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query if the character is a villain
            is_villain = frame.simple_query(f""Is the character with ID {character_id} a villain?"", to_yesno=True)
            # Check for falling action
            is_falling = frame.simple_query(""Is there a falling action in the scene?"", to_yesno=True)

            if ""yes"" in is_villain.lower() and ""yes"" in is_falling.lower():
                villain_fall_detected = True
                # Record the frame and description of the event
                event_description = frame.simple_query(""Describe the falling event."")
                info[f""Villain fall event at frame {i}""] = event_description

    # Determine if the trope is applicable based on the collected information
    if villain_fall_detected:
        answer = ""yes""
        reason = ""The trope 'Disney Villain Death' is applicable as a villain character was observed falling off or out of something in the film.""
    else:
        answer = ""no""
        reason = ""The trope 'Disney Villain Death' is not applicable as no villain character was observed falling off or out of something in the film.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_37|Your Cheating Heart|"Is the trope ""Your Cheating Heart"", which means ""Cheating on your partner."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Your Cheating Heart
    # Definition: A narrative trope where a character is unfaithful to their partner.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find interactions between characters that might suggest romantic or secretive behavior.
    # 2. Character Analysis: Identify characters and collect their interactions with others, especially those that might suggest a romantic or secretive nature.
    # 3. Answer Selection: Use the collected data to determine if the ""Your Cheating Heart"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_interactions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all persons in the frame
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query about the person's actions and interactions
            person_action = frame.simple_query(""What's he/she doing?"")
            person_interaction = frame.simple_query(""Who is he/she interacting with?"")

            if person_id not in info[""character_interactions""]:
                info[""character_interactions""][person_id] = []

            info[""character_interactions""][person_id].append({
                ""frame"": i,
                ""action"": person_action,
                ""interaction"": person_interaction
            })

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_38|"\""The Reason You Suck\"" Speech"|"Is the trope ""\""The Reason You Suck\"" Speech"", which means ""One character delivers a speech to another character on all the reasons why that other character sucks or is a horrible person."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: ""The Reason You Suck"" Speech
    # Definition: One character delivers a speech to another character on all the reasons why that other character sucks or is a horrible person.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find any instance where one character is speaking to another.
    # 2. Speech Analysis: Determine if the speech includes elements that are critical of the other character's behavior or personality.
    # 3. Answer Selection: Use the collected information to decide if the trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    speech_found = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check if there are at least two people in the frame
        people = frame.find(""person"")
        if len(people) >= 2:
            # Assume function to check if one person is speaking to another
            speaking_query = frame.simple_query(""Is one person speaking to another?"", to_yesno=True)
            if ""yes"" in speaking_query.lower():
                # Get the content of the speech
                speech_content = frame.simple_query(""What is being said in the speech?"")
                # Check if the speech content matches the trope criteria
                critical_speech = frame.llm_query(f""Does the speech content '{speech_content}' describe reasons why the listener sucks or is a horrible person?"", to_yesno=True)
                if ""yes"" in critical_speech.lower():
                    speech_found = True
                    info[f""Critical speech at frame {i}""] = speech_content

    # Determine if the trope is present based on the analysis
    if speech_found:
        answer = ""yes""
        reason = ""A speech was found where one character criticizes another, matching the trope.""
    else:
        answer = ""no""
        reason = ""No speech was found that matches the criteria of the trope.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_39|Tempting Fate|"Is the trope ""Tempting Fate"", which means ""Tempting Fate is when a character says something that dares the universe into making things miserable for them, and the universe takes them up 
on the challenge."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Tempting Fate
    # Definition: Tempting Fate is when a character says something that dares the universe into making things miserable for them, and the universe takes them up on the challenge.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where characters might be saying something that could be considered as tempting fate.
    # 2. Contextual Analysis: Analyze the dialogue and subsequent events to see if the universe indeed responds negatively.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Tempting Fate"" is relevant to the movie.

    video_segment = VideoSegment(video, annotation)
    info = {}
    fate_tempted = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query the dialogue in the frame
        dialogue = frame.simple_query(""What is being said?"")
        # Check if the dialogue tempts fate
        tempting_fate_query = frame.llm_query(f""Does the dialogue '{dialogue}' tempt fate?"", to_yesno=True)
        if ""yes"" in tempting_fate_query.lower():
            # Check for negative consequences in subsequent frames
            if i + 1 < video_segment.num_frames:
                next_frame = video_segment.frame_from_index(i + 1)
                negative_consequence = next_frame.simple_query(""What happens next?"", to_yesno=True)
                if ""yes"" in negative_consequence.lower():
                    fate_tempted = True
                    info[f""Frame {i}""] = {
                        ""Dialogue"": dialogue,
                        ""Tempting Fate"": tempting_fate_query,
                        ""Negative Consequence"": negative_consequence
                    }
                    break

    # Determine the answer based on whether fate was tempted
    answer = ""yes"" if fate_tempted else ""no""
    reason = ""The trope 'Tempting Fate' is relevant as a character's dialogue tempted fate and led to negative consequences."" if fate_tempted else ""The trope 'Tempting Fate' is not relevant as no dialogue was found that tempted fate with negative consequences.""
    
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_40|Disproportionate Retribution|"Is the trope ""Disproportionate Retribution"", which means ""the situation where a person let the opponent know that if they so much as sneeze on someone you protect, it will cost them a limb."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Disproportionate Retribution
    # Definition: A situation where a person reacts with excessive severity to a minor or reasonable action.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify any potential conflicts or interactions that might lead to retribution.
    # 2. Event Analysis: Identify the nature of the initial action and the response to determine if the retribution is disproportionate.
    # 3. Answer Selection: Use the collected information to determine if the ""Disproportionate Retribution"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query the frame for any conflict or aggressive interaction
        conflict_description = frame.simple_query(""Describe any conflict or aggressive interaction in the scene."")
        if conflict_description:
            # Further query to understand the nature of the initial action and the response
            initial_action = frame.simple_query(""What was the initial action that led to the conflict?"")
            response_action = frame.simple_query(""What was the response to the initial action?"")
            info[f""Frame {i}""] = {
                ""Conflict Description"": conflict_description,
                ""Initial Action"": initial_action,
                ""Response Action"": response_action
            }

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_41|Badass Boast|"Is the trope ""Badass Boast"", which means ""The character has got to be pretty impressive to be able to make this kind of boast convincingly, though sometimes a weaker character will 
bluff like this."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Badass Boast
    # Definition: A character makes a boast that is bold and impressive, often highlighting their own strength, skill, or prowess.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where characters are speaking or interacting in a way that could be interpreted as boasting.
    # 2. Dialogue Analysis: Focus on extracting and analyzing dialogue to identify boasts that fit the trope's definition.
    # 3. Contextual Relevance: Determine the context in which the boasts are made to assess whether they are indeed ""badass"" or merely bluffs.
    # 4. Answer Selection: Use the collected information to decide if the ""Badass Boast"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    boastful_statements = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query to check if there is any dialogue in the frame
        dialogue_presence = frame.simple_query(""Is there any dialogue?"", to_yesno=True)
        if ""yes"" in dialogue_presence.lower():
            # Extract the dialogue and analyze it for boasting content
            dialogue = frame.simple_query(""What is being said?"")
            is_boast = frame.llm_query(f""Does the dialogue '{dialogue}' contain a boast?"", to_yesno=True)
            if ""yes"" in is_boast.lower():
                # Further analyze if the boast is impressive or badass
                boast_quality = frame.llm_query(f""Is the boast in the dialogue '{dialogue}' impressive or badass?"", to_yesno=True)
                if ""yes"" in boast_quality.lower():
                    boastful_statements.append(dialogue)
                    info[f""Boast in frame {i}""] = dialogue

    # If there are boastful statements that are considered badass, the trope is relevant
    if boastful_statements:
        answer = ""yes""
        reason = ""The video contains one or more instances of characters making impressive boasts.""
    else:
        answer = ""no""
        reason = ""There are no instances of badass boasts in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_42|Groin Attack|"Is the trope ""Groin Attack"", which means ""Groin attack"", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Groin Attack
    # Definition: A trope where a character is hit or attacked in the groin area, often used for comedic effect.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect any instance of a groin attack.
    # 2. Event Detection: Look for visual cues or actions that indicate a groin attack, such as a kick or a hit directed towards the groin.
    # 3. Contextual Analysis: Ensure the context supports the interpretation of the action as a groin attack (e.g., reactions of characters, comedic setup).
    # 4. Answer Selection: Use the collected information to determine if the ""Groin Attack"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Detect potential groin attack events
        attack_query = frame.simple_query(""Is there an attack directed towards the groin?"", to_yesno=True)
        if ""yes"" in attack_query.lower():
            # Collect additional context to confirm the trope
            context = frame.simple_query(""Describe the context of the attack."")
            info[f""Groin attack in frame {i}""] = context

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_43|Roaring Rampage of Revenge|"Is the trope ""Roaring Rampage of Revenge"", which means ""The Roaring Rampage of Revenge differs from the standard Revenge plot in that our hero dispenses with the Machiavellian plotting that would 
define a classic revenge tale and goes straight for the bloodshed."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Roaring Rampage of Revenge
    # Definition: A narrative where the protagonist reacts to a grievance or loss with immediate and intense violence, rather than calculated revenge.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to identify scenes of intense action or violence.
    # 2. Character Analysis: Identify the protagonist and analyze their motivations and actions.
    # 3. Event Contextualization: Determine if the violent actions are in direct response to a personal grievance or loss.
    # 4. Answer Selection: Use the collected data to decide if the ""Roaring Rampage of Revenge"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""actions"": {},
        ""motivations"": {},
        ""responses"": {}
    }

    protagonist_id = None
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters and actions
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            action = frame.simple_query(""What is the person doing?"")
            emotion = frame.simple_query(""What is the person's emotion?"")

            # Assuming a function to determine if the person is the protagonist
            if 'protagonist' in action.lower() or 'protagonist' in emotion.lower():
                protagonist_id = person_id

            if person_id not in info[""actions""]:
                info[""actions""][person_id] = []
            info[""actions""][person_id].append(action)

            # Collect motivations if the person is identified as the protagonist
            if person_id == protagonist_id:
                motivation = frame.simple_query(""What motivates the protagonist's actions?"")
                info[""motivations""][person_id] = motivation

                # Check if the action is a response to a grievance or loss
                if 'revenge' in motivation.lower() or 'loss' in motivation.lower():
                    response = frame.simple_query(""Is this action a response to a personal grievance or loss?"", to_yesno=True)
                    info[""responses""][person_id] = response

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_44|Big Damn Heroes|"Is the trope ""Big Damn Heroes"", which means ""Any time the heroes/anti heroes get to save the day in a big, awesome manner."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Big Damn Heroes
    # Definition: Any time the heroes/anti heroes get to save the day in a big, awesome manner.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find moments where characters perform significant, heroic actions.
    # 2. Character Analysis: Identify characters and their actions, especially looking for dramatic, pivotal moments of rescue or defense.
    # 3. Answer Selection: Use the collected information to determine if the ""Big Damn Heroes"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    hero_moments = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for any heroic actions in the frame
        heroic_action = frame.simple_query(""Is there a heroic action?"", to_yesno=True)
        if ""yes"" in heroic_action.lower():
            # Describe the action and identify the character
            action_description = frame.simple_query(""Describe the heroic action."")
            for character in frame.find(""hero""):
                character_id = video_segment.face_identify(character)
                if character_id is None:
                    continue
                character_action = character.simple_query(""What's he/she doing?"")
                character_emotion = character.simple_query(""What's his/her emotion?"")
                hero_moments.append({
                    ""frame"": i,
                    ""action"": action_description,
                    ""character_id"": character_id,
                    ""character_action"": character_action,
                    ""character_emotion"": character_emotion
                })

    info['heroic_moments'] = hero_moments

    # Determine if the trope is applicable based on the collected heroic moments
    if hero_moments:
        answer = ""yes""
        reason = ""There are significant heroic actions that align with the 'Big Damn Heroes' trope.""
    else:
        answer = ""no""
        reason = ""No significant heroic actions were found that would align with the 'Big Damn Heroes' trope.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_45|Heroic Sacrifice|"Is the trope ""Heroic Sacrifice"", which means ""A character saves another/others from harm and is killed, crippled, or maimed as a result."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Heroic Sacrifice
    # Definition: A character saves another/others from harm and is killed, crippled, or maimed as a result.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find potential scenes of sacrifice.
    # 2. Character Analysis: Identify characters and their actions, especially looking for acts of saving others.
    # 3. Event Outcome: Determine the outcome for the character who performed the act.
    # 4. Answer Selection: Use the collected information to decide if the ""Heroic Sacrifice"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {},
        ""sacrificial_events"": []
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query what the character is doing
            action_description = frame.simple_query(""What's he/she doing?"")
            # Check if the action is sacrificial and has severe consequences
            is_sacrificial = ""saves"" in action_description.lower() and (""killed"" in action_description.lower() or ""crippled"" in action_description.lower() or ""maimed"" in action_description.lower())
            if is_sacrificial:
                info[""sacrificial_events""].append({
                    ""frame_index"": i,
                    ""character_id"": character_id,
                    ""action"": action_description
                })

            # Collect general actions for each character
            if character_id not in info[""character_actions""]:
                info[""character_actions""][character_id] = []
            info[""character_actions""][character_id].append(action_description)

    # Determine if the trope is applicable based on the collected sacrificial events
    if info[""sacrificial_events""]:
        answer = ""yes""
        reason = ""There are characters who performed sacrificial acts resulting in severe consequences.""
    else:
        answer = ""no""
        reason = ""No sacrificial acts with severe consequences were observed.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_46|Screw This, I'm Outta Here!|"Is the trope ""Screw This, I'm Outta Here!"", which means ""Screw you guys, I'm going home."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Screw This, I'm Outta Here!
    # Definition: A character decides to abandon the group or situation they are in, often after a frustrating or morally conflicting scenario.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find any character expressing frustration or preparing to leave.
    # 2. Emotional and Contextual Analysis: Look for visual cues of frustration, dialogue indicating a decision to leave, and actions that signify leaving.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Screw This, I'm Outta Here!"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    character_leaving = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for dialogue or actions related to leaving
        leaving_query = frame.simple_query(""Is someone leaving or expressing the desire to leave?"", to_yesno=True)
        if ""yes"" in leaving_query.lower():
            # Get more details about the situation
            context = frame.simple_query(""What is the context or reason for leaving?"")
            info[f""Frame {i}""] = {""Leaving"": True, ""Context"": context}
            character_leaving = True
        else:
            info[f""Frame {i}""] = {""Leaving"": False}

    # Determine if the trope is relevant based on the collected information
    if character_leaving:
        answer = ""yes""
        reason = ""There are instances where characters express a desire to leave or are seen leaving due to frustration or conflict.""
    else:
        answer = ""no""
        reason = ""No significant instances of characters leaving due to frustration or conflict were observed.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_47|Kick the Dog|"Is the trope ""Kick the Dog"", which means ""When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift 
audience sympathy away from him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Kick the Dog
    # Definition: When a character does something evil for no apparent gain, because the author wants to demonstrate that he's not a nice guy and shift audience sympathy away from him.
    # Thought Process:
    # 1. Frame Selection: Iterate through each frame to find potential 'Kick the Dog' moments where a character acts cruelly without apparent gain.
    # 2. Character Analysis: Identify characters and their actions, especially looking for unnecessary cruelty.
    # 3. Answer Selection: Use the collected information to determine if the trope is present.
    
    video_segment = VideoSegment(video, annotation)
    info = {}
    
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters and their actions in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            character_action = frame.simple_query(""What's he/she doing?"")
            character_emotion = frame.simple_query(""What's his/her emotion?"")
            
            # Check if the action could be considered as unnecessarily cruel
            is_cruel = frame.llm_query(f""Is the action '{character_action}' considered unnecessarily cruel?"", to_yesno=True)
            
            if 'yes' in is_cruel.lower():
                # Collect information about the cruel action and the character's emotion
                if character_id not in info:
                    info[character_id] = []
                info[character_id].append({
                    ""frame"": i,
                    ""action"": character_action,
                    ""emotion"": character_emotion,
                    ""cruelty_confirmed"": is_cruel
                })
    
    # After collecting information, use it to determine the presence of the trope
    if any(info.values()):  # If there's any recorded instance of cruelty
        answer = ""yes""
        reason = ""There are instances where characters act cruelly without apparent gain.""
    else:
        answer = ""no""
        reason = ""No instances of unnecessary cruelty were found.""
    
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_48|Pet the Dog|"Is the trope ""Pet the Dog"", which means ""Show the nasty old crank petting a dog, and you show the audience, aw shucks, they're not that bad of a person after all."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Pet the Dog
    # Definition: A narrative trope where a seemingly unpleasant character does something kind, like petting a dog, to show they have a softer side.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where a character interacts with a dog.
    # 2. Character Analysis: Identify the character and assess their general behavior throughout the video to determine if they are generally perceived as unpleasant.
    # 3. Answer Selection: Use the collected data to decide if the ""Pet the Dog"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_interactions"": {},
        ""character_descriptions"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Find all instances of characters and dogs in the frame
        characters = frame.find(""person"")
        dogs = frame.find(""dog"")

        for character in characters:
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue

            # Check if this character is interacting with a dog
            for dog in dogs:
                if character.overlaps_with(dog.left, dog.lower, dog.right, dog.upper):
                    interaction_description = frame.simple_query(""What is the character doing with the dog?"")
                    if ""petting"" in interaction_description.lower():
                        # Collect character description to assess if they are generally unpleasant
                        character_description = character.simple_query(""Describe the character's general behavior."")
                        info[""character_interactions""][character_id] = interaction_description
                        info[""character_descriptions""][character_id] = character_description

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_49|Villainous Breakdown|"Is the trope ""Villainous Breakdown"", which means ""The tendency of relatively calm and composed villains to lose their cool over the course of the story."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Villainous Breakdown
    # Definition: The tendency of relatively calm and composed villains to lose their cool over the course of the story.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to observe the villain's behavior from start to end.
    # 2. Behavioral Analysis: Track changes in the villain's demeanor, actions, and interactions.
    # 3. Answer Selection: Use the collected data to determine if a ""Villainous Breakdown"" occurs.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""villain_actions"": {}
    }

    # Iterate through each frame to analyze the villain's behavior
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Find all characters identified as 'villain'
        for villain in frame.find(""villain""):
            villain_id = video_segment.face_identify(villain)
            if villain_id is None:
                continue
            # Query about the villain's current action and emotional state
            villain_action = frame.simple_query(""What is the villain doing?"")
            villain_emotion = frame.simple_query(""What is the villain's emotional state?"")

            # Store the villain's actions and emotions indexed by frame
            if villain_id not in info[""villain_actions""]:
                info[""villain_actions""][villain_id] = []
            info[""villain_actions""][villain_id].append({
                ""frame"": i,
                ""action"": villain_action,
                ""emotion"": villain_emotion
            })

    # After collecting information, determine if there is a breakdown
    breakdown_occurred = False
    for villain_id, actions in info[""villain_actions""].items():
        calm_count = 0
        breakdown_count = 0
        for action_info in actions:
            if ""calm"" in action_info[""emotion""]:
                calm_count += 1
            if ""angry"" in action_info[""emotion""] or ""frustrated"" in action_info[""emotion""]:
                breakdown_count += 1

        # Check if the breakdown is significant compared to their usual calm state
        if breakdown_count > calm_count / 2:  # More than half of the time they are breaking down compared to being calm
            breakdown_occurred = True
            break

    answer = ""yes"" if breakdown_occurred else ""no""
    reason = ""The villain shows a significant loss of composure compared to earlier calm behavior."" if breakdown_occurred else ""The villain maintains composure throughout the story.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_50|Precision F-Strike|"Is the trope ""Precision F-Strike"", which means ""When a character suddenly swears in an uncharacteristically strong manner, or when a swear is unexpectedly used in a work with mild language."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Precision F-Strike
    # Definition: When a character suddenly swears in an uncharacteristically strong manner, or when a swear is unexpectedly used in a work with mild language.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for dialogue content.
    # 2. Dialogue Analysis: Detect sudden use of strong language in a context where it is unexpected.
    # 3. Answer Selection: Use the collected information to determine if the trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    sudden_swear_found = False
    reason = """"

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query the dialogue in the frame
        dialogue = frame.simple_query(""What is being said?"")
        # Check for strong language
        contains_swear = frame.llm_query(f""Does the dialogue '{dialogue}' contain strong language?"", to_yesno=True)
        
        if ""yes"" in contains_swear.lower():
            previous_dialogue = frame.simple_query(""What was said in the previous scene?"", to_yesno=False)
            # Check if the previous dialogue was mild
            previous_was_mild = frame.llm_query(f""Is the dialogue '{previous_dialogue}' considered mild language?"", to_yesno=True)
            
            if ""yes"" in previous_was_mild.lower():
                sudden_swear_found = True
                info[f""Swearing at frame {i}""] = dialogue
                reason = f""Sudden strong language found in a previously mild context at frame {i}.""
                break

    answer = ""yes"" if sudden_swear_found else ""no""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_51|Cluster F-Bomb|"Is the trope ""Cluster F-Bomb"", which means ""Lots of swearing occur."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Cluster F-Bomb
    # Definition: A trope where a significant amount of swearing occurs in a short period.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for dialogue content.
    # 2. Detection of Swearing: Check for the presence of swear words in the dialogues.
    # 3. Answer Selection: Determine if the amount and concentration of swearing fit the trope definition.

    video_segment = VideoSegment(video, annotation)
    info = {}
    swear_word_count = 0
    total_dialogue_fragments = 0

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Extract dialogue from the frame and analyze it for swear words
        dialogue = frame.simple_query(""What is being said?"")
        # Assuming a function exists to count swear words in a text
        num_swear_words = count_swear_words(dialogue)
        swear_word_count += num_swear_words
        total_dialogue_fragments += 1
        info[f""Frame {i + 1}""] = {""dialogue"": dialogue, ""swear_words"": num_swear_words}

    # Determine if the concentration of swear words is significant
    if total_dialogue_fragments > 0:
        average_swear_words_per_fragment = swear_word_count / total_dialogue_fragments
    else:
        average_swear_words_per_fragment = 0

    # Define a threshold for what constitutes a ""Cluster F-Bomb"" scenario
    threshold = 0.5  # Example threshold, this might need tuning based on the context or explicit definitions
    if average_swear_words_per_fragment > threshold:
        answer = ""yes""
        reason = ""The concentration of swear words per dialogue fragment is high, indicating a 'Cluster F-Bomb' trope.""
    else:
        answer = ""no""
        reason = ""The concentration of swear words per dialogue fragment is not high enough for a 'Cluster F-Bomb' trope.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_52|Jerkass Has a Point|"Is the trope ""Jerkass Has a Point"", which means ""When a jerkass is right."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Jerkass Has a Point
    # Definition: A narrative trope where a character, often disliked or considered a jerk, makes a valid or insightful point.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to find instances where the character in question speaks or interacts with others.
    # 2. Character Analysis: Identify the character and analyze their dialogue and interactions to determine if they make a valid point.
    # 3. Answer Selection: Use the collected data to decide whether the ""Jerkass Has a Point"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_dialogues"": {},
        ""valid_points"": []
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Get dialogue of the character
            dialogue = frame.simple_query(""What is the character saying?"")
            # Check if the dialogue contains a valid or insightful point
            is_valid_point = frame.llm_query(f""Does the statement '{dialogue}' contain a valid or insightful point?"", to_yesno=True)
            if character_id not in info[""character_dialogues""]:
                info[""character_dialogues""][character_id] = []
            info[""character_dialogues""][character_id].append(dialogue)
            if ""yes"" in is_valid_point.lower():
                info[""valid_points""].append(dialogue)

    # After collecting information, use it to determine the presence of the trope
    if info[""valid_points""]:
        answer = ""yes""
        reason = ""The character considered a jerk made valid or insightful points.""
    else:
        answer = ""no""
        reason = ""No valid or insightful points were made by the character considered a jerk.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_53|Idiot Ball|"Is the trope ""Idiot Ball"", which means ""A moment where a character's stupidity fuels an episode, or a small plot line."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Idiot Ball
    # Definition: A moment where a character's stupidity fuels an episode, or a small plot line.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find potential moments of significant character stupidity.
    # 2. Contextual Analysis: Assess the context in which the actions occur to determine if they are driven by stupidity.
    # 3. Answer Selection: Use the collected information to determine if the ""Idiot Ball"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query each frame to see if there is an action that could be considered stupid
        action_query = ""Is there an action taken by a character that could be considered significantly stupid?""
        action_response = frame.simple_query(action_query, to_yesno=True)
        if ""yes"" in action_response.lower():
            # Get more details about the action and the context
            detailed_action = frame.simple_query(""What is the stupid action and what are the consequences?"")
            info[f""Stupid action in frame {i}""] = detailed_action

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_54|Batman Gambit|"Is the trope ""Batman Gambit"", which means ""A plan that revolves entirely around people doing exactly what you'd expect them to do."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Batman Gambit
    # Definition: A plan that revolves entirely around people doing exactly what you'd expect them to do.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify key characters and their actions.
    # 2. Character Analysis: Determine if characters are acting predictably based on prior knowledge or character traits.
    # 3. Answer Selection: Use the collected data to decide if the ""Batman Gambit"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {},
        ""predictable_behaviors"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the character's action
            character_action = frame.simple_query(""What's he/she doing?"")
            # Store character actions
            if character_id not in info[""character_actions""]:
                info[""character_actions""][character_id] = []
            info[""character_actions""][character_id].append(character_action)
            # Check if the action is predictable based on previous actions or known traits
            is_predictable = frame.llm_query(f""Is the action '{character_action}' by '{character_id}' predictable based on their known traits or previous actions?"", to_yesno=True)
            if ""yes"" in is_predictable.lower():
                if character_id not in info[""predictable_behaviors""]:
                    info[""predictable_behaviors""][character_id] = []
                info[""predictable_behaviors""][character_id].append(character_action)

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_55|Police are Useless|"Is the trope ""Police are Useless"", which means ""Whenever someone in film or on TV reports a murder, or a monster, or a stalker or whatever, the police come as close to ignoring them 
as procedure will allow. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Police are Useless
    # Definition: Whenever someone in film or on TV reports a murder, or a monster, or a stalker or whatever, the police come as close to ignoring them as procedure will allow.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find interactions involving police.
    # 2. Contextual Analysis: Assess the response of the police in these interactions to determine if they are dismissive or ineffective.
    # 3. Answer Selection: Use the collected information to decide if the trope ""Police are Useless"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    police_ineffectiveness = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for the presence of police and any reported incidents
        if frame.exists(""police"") and frame.exists(""incident""):
            # Query the response of the police to the incident
            police_response = frame.simple_query(""How do the police respond to the incident?"")
            info[f""Frame {i}""] = {""police_response"": police_response}
            # Determine if the response can be considered as ignoring or ineffective
            if ""ignore"" in police_response.lower() or ""ineffective"" in police_response.lower():
                police_ineffectiveness.append(True)
            else:
                police_ineffectiveness.append(False)

    # If any frame shows police ineffectiveness, consider the trope as applicable
    if any(police_ineffectiveness):
        answer = ""yes""
        reason = ""There are instances where police responses were ineffective or ignoring the incidents.""
    else:
        answer = ""no""
        reason = ""All observed police responses were appropriate and effective.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_56|The Dragon|"Is the trope ""The Dragon"", which means ""There is almost always someone, person or monster, The Hero has to get past to get at the Big Bad."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: The Dragon
    # Definition: There is almost always someone, person or monster, The Hero has to get past to get at the Big Bad.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to identify key characters and their roles in the narrative.
    # 2. Character Analysis: Identify the antagonist (The Dragon) who acts as a significant obstacle to the protagonist.
    # 3. Answer Selection: Determine if the identified character fits the trope of ""The Dragon"" and answer the query.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_roles"": {},
        ""key_events"": {}
    }

    # Iterate through video frames to analyze characters and their actions
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the role and action of the character
            character_role = frame.simple_query(""What role does this character play in the story?"")
            character_action = frame.simple_query(""What is this character doing right now?"")

            # Store character roles and actions
            if character_id not in info[""character_roles""]:
                info[""character_roles""][character_id] = character_role
            info[""key_events""][f""{i} frame""] = character_action

    # Analyze the collected information to determine if there is a character fitting the description of ""The Dragon""
    dragon_found = False
    for character_id, role in info[""character_roles""].items():
        if ""obstacle"" in role.lower() and ""antagonist"" in role.lower():
            dragon_found = True
            break

    # Select the answer based on whether a ""Dragon"" character was identified
    answer = ""yes"" if dragon_found else ""no""
    reason = ""A character fitting the role of 'The Dragon' was identified."" if dragon_found else ""No character fitting the role of 'The Dragon' was found.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_57|Cool Car|"Is the trope ""Cool Car"", which means ""The hero's ride has to be just as unique and awesome as the hero is. Enter a Cool Car!"", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Cool Car
    # Definition: The hero's ride has to be just as unique and awesome as the hero is. Enter a Cool Car!
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances of cars.
    # 2. Car Analysis: Determine if any identified cars match the criteria of being ""cool"" or unique as per the hero's character.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Cool Car"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    cool_car_found = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Find all instances of cars in the frame
        cars = frame.find(""car"")
        for car in cars:
            # Query each car to see if it matches the ""cool"" criteria
            is_cool_car = car.simple_query(""Is this car unique and awesome?"", to_yesno=True)
            if ""yes"" in is_cool_car.lower():
                cool_car_found = True
                car_description = car.simple_query(""Describe the car."")
                info[f""Cool car in frame {i}""] = car_description

    # Determine if the trope is relevant based on the presence of a cool car
    if cool_car_found:
        answer = ""yes""
        reason = ""The movie features a unique and awesome car, fitting the 'Cool Car' trope.""
    else:
        answer = ""no""
        reason = ""No unique or awesome car fitting the 'Cool Car' trope was found in the movie.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_58|Body Horror|"Is the trope ""Body Horror"", which means ""This is any form of horror or squickiness involving body parts, parasitism, disfigurement, mutation, or unsettling bodily configuration."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Body Horror
    # Definition: This is any form of horror or squickiness involving body parts, parasitism, disfigurement, mutation, or unsettling bodily configuration.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for visual cues of body horror such as disfigurement, mutation, or other unsettling changes.
    # 2. Contextual Analysis: Look for scenes that explicitly show or imply horror elements related to the body.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Body Horror"" is relevant to the movie.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for visual cues of body horror
        horror_query = frame.simple_query(""Are there any visual cues of body horror?"", to_yesno=True)
        if ""yes"" in horror_query.lower():
            # Describe the horror elements
            horror_description = frame.simple_query(""Describe the body horror elements."")
            info[f""Body horror in frame {i}""] = horror_description

    # After collecting information, use it to determine the relevance of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_59|The Reveal|"Is the trope ""The Reveal"", which means ""A character is revealed as another character's father, a god, or secret suitor or arch nemesis in disguise."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: The Reveal
    # Definition: A character is revealed as another character's father, a god, or secret suitor or arch nemesis in disguise.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find any significant reveal or transformation of a character's identity.
    # 2. Character Analysis: Identify each character and collect their actions or character traits before and after the reveal.
    # 3. Answer Selection: Use the collected data to decide whether the ""The Reveal"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_changes"": {},
        ""significant_reveals"": []
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query character's role or identity in the scene
            character_role_query = ""What is the role or identity of this character in the scene?""
            character_role = frame.simple_query(character_role_query)
            # Track character identity changes across frames
            if character_id not in info[""character_changes""]:
                info[""character_changes""][character_id] = [character_role]
            else:
                if info[""character_changes""][character_id][-1] != character_role:
                    info[""character_changes""][character_id].append(character_role)
                    info[""significant_reveals""].append({
                        ""frame"": i,
                        ""character_id"": character_id,
                        ""before"": info[""character_changes""][character_id][-2],
                        ""after"": character_role
                    })

    # Determine if any of the changes match the trope definition
    for reveal in info[""significant_reveals""]:
        if ""father"" in reveal[""after""] or ""god"" in reveal[""after""] or ""suitor"" in reveal[""after""] or ""nemesis"" in reveal[""after""]:
            answer, reason = ""yes"", f""Character {reveal['character_id']} revealed as {reveal['after']} from {reveal['before']}""
            return answer, reason, info

    answer, reason = ""no"", ""No significant character reveal matching the trope criteria was found.""
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_60|Curb-Stomp Battle|"Is the trope ""Curb-Stomp Battle"", which means ""A fight that's extremely one-sided, where one side just absolutely trashes the other with little-to-no effort"", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Curb-Stomp Battle
    # Definition: A fight that's extremely one-sided, where one side just absolutely trashes the other with little-to-no effort.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find scenes of conflict or battle.
    # 2. Conflict Analysis: Determine the balance of power in the conflict, looking for visual cues of dominance or helplessness.
    # 3. Answer Selection: Use the collected information to decide if the ""Curb-Stomp Battle"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    dominant_scenes = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query if there's a conflict or battle in the frame
        conflict_presence = frame.simple_query(""Is there a conflict or battle happening?"", to_yesno=True)
        if ""yes"" in conflict_presence.lower():
            # Analyze the balance of power in the conflict
            balance_query = ""Describe the balance of power in the conflict.""
            balance_description = frame.simple_query(balance_query)
            info[f""Frame {i} conflict balance""] = balance_description
            # Check if one side is overwhelmingly dominant
            if ""overwhelmingly dominant"" in balance_description.lower():
                dominant_scenes.append(i)

    # If there are any overwhelmingly dominant scenes, the trope is likely present
    if dominant_scenes:
        answer = ""yes""
        reason = f""The trope 'Curb-Stomp Battle' is identified in frames: {dominant_scenes}.""
    else:
        answer = ""no""
        reason = ""No overwhelming dominance was observed in any conflict scenes.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_61|Cassandra Truth|"Is the trope ""Cassandra Truth"", which means ""Sometimes people just won't believe you even though you are telling the truth, because the truth sounds insane."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Cassandra Truth
    # Definition: Sometimes people just won't believe you even though you are telling the truth, because the truth sounds insane.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where a character is ignored or not believed despite their earnestness.
    # 2. Emotional and Contextual Analysis: Look for visual cues of disbelief or dismissal from other characters.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Cassandra Truth"" is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {}
    disbelief_events = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query each frame to see if there's a character who is being earnest but not believed
        character_query = ""Is there a character who is earnestly telling something important but not being believed?""
        is_disbelieved = frame.simple_query(character_query, to_yesno=True)
        
        if ""yes"" in is_disbelieved.lower():
            # Collect more context about the disbelief
            context_query = ""What is the character saying and how are others reacting?""
            context = frame.simple_query(context_query)
            disbelief_events.append(f""Frame {i}: {context}"")
    
    # Store the collected disbelief events in the info dictionary
    info['disbelief_events'] = disbelief_events

    # If there are any recorded events of disbelief, it suggests the trope might be relevant
    if disbelief_events:
        answer = ""yes""
        reason = ""There are instances where characters are not believed despite telling the truth.""
    else:
        answer = ""no""
        reason = ""No clear instances of the trope were observed in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_62|Blatant Lies|"Is the trope ""Blatant Lies"", which means ""A glaringly obvious lie."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Blatant Lies
    # Definition: A glaringly obvious lie.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect any dialogue or actions that might indicate a lie.
    # 2. Dialogue Analysis: Check for discrepancies between what is said and the known facts or visual evidence.
    # 3. Answer Selection: Use the select_answer API to determine if the ""Blatant Lies"" trope is applicable based on the collected information.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for dialogue that might be a lie
        dialogue = frame.simple_query(""What is being said?"")
        # Check if the dialogue is a lie by comparing it with known facts or visual evidence
        is_lie = frame.llm_query(f""Is the statement '{dialogue}' a lie based on the visual evidence or known facts?"", to_yesno=True)
        
        if ""yes"" in is_lie.lower():
            info[f""Lie detected in frame {i}""] = dialogue

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_63|Crapsack World|"Is the trope ""Crapsack World"", which means ""A Crapsack World is a horrible setting of the world where it's dark and hopeless"", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Crapsack World
    # Definition: A Crapsack World is a horrible setting where the world is dark and hopeless.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect signs of darkness or hopelessness.
    # 2. Contextual Analysis: Look for visual cues or dialogues that indicate a negative, oppressive environment.
    # 3. Answer Selection: Use the collected information to determine if the ""Crapsack World"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    dark_scenes_count = 0
    total_scenes_count = 0

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query the frame for visual and thematic darkness
        scene_description = frame.simple_query(""Describe the scene atmosphere."")
        is_dark = ""dark"" in scene_description.lower() or ""hopeless"" in scene_description.lower()
        info[f""Frame {i} description""] = scene_description
        if is_dark:
            dark_scenes_count += 1
        total_scenes_count += 1

    # Determine if the majority of the scenes are dark or hopeless
    if dark_scenes_count / total_scenes_count > 0.5:
        answer = ""yes""
        reason = ""More than half of the scenes are described as dark or hopeless.""
    else:
        answer = ""no""
        reason = ""Less than half of the scenes are described as dark or hopeless.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_64|Comically Missing the Point|"Is the trope ""Comically Missing the Point"", which means ""A character completely misses a really obvious point for comic effect."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Comically Missing the Point
    # Definition: A character completely misses a really obvious point for comic effect.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where a character might be missing an obvious point.
    # 2. Dialogue Analysis: Check for dialogues that indicate misunderstanding or obliviousness to the context.
    # 3. Emotional and Contextual Analysis: Analyze the characters' expressions and reactions to ensure the scene is intended for comic effect.
    # 4. Answer Selection: Use the collected information to determine if the trope is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for dialogues indicating misunderstanding
        dialogue_query = ""What is being said in this scene?""
        dialogue = frame.simple_query(dialogue_query)
        misunderstanding_query = f""Is there a misunderstanding or missing point in the dialogue '{dialogue}'?""
        misunderstanding = frame.llm_query(misunderstanding_query, to_yesno=True)

        if ""yes"" in misunderstanding.lower():
            # Collect additional context to confirm comic effect
            context_query = ""Describe the context and reactions of other characters.""
            context_description = frame.simple_query(context_query)
            comic_effect_query = f""Is the misunderstanding intended for comic effect in the context '{context_description}'?""
            comic_effect = frame.llm_query(comic_effect_query, to_yesno=True)

            if ""yes"" in comic_effect.lower():
                info[f""Comic misunderstanding at frame {i}""] = {
                    ""dialogue"": dialogue,
                    ""context"": context_description
                }

    # Answer the query using the collected information
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_65|Fanservice|"Is the trope ""Fanservice"", which means ""The use of sex or sexualized situations to reward or entice viewers."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Fanservice
    # Definition: The use of sex or sexualized situations to reward or entice viewers.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential sexualized content or situations.
    # 2. Contextual Analysis: Determine the context in which these situations occur to assess if they are used to entice viewers.
    # 3. Answer Selection: Use the collected information to decide if the trope ""Fanservice"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    sexual_content_detected = False

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for sexualized content or situations
        sexual_content_query = frame.simple_query(""Is there any sexual or sexualized content in this frame?"", to_yesno=True)
        if ""yes"" in sexual_content_query.lower():
            sexual_content_detected = True
            # Get more details about the content
            content_description = frame.simple_query(""Describe the sexual or sexualized content in this frame."")
            info[f""Sexual content in frame {i}""] = content_description

    # If sexual content is detected, analyze the context to see if it's used to entice viewers
    if sexual_content_detected:
        context_query = ""Is the sexual or sexualized content used to attract or reward viewers?""
        context_analysis = video_segment.llm_query(context_query, to_yesno=True)
        info[""Context analysis""] = context_analysis
        if ""yes"" in context_analysis.lower():
            answer = ""yes""
            reason = ""Sexual or sexualized content is used to entice viewers.""
        else:
            answer = ""no""
            reason = ""Sexual or sexualized content is present but not used to entice viewers.""
    else:
        answer = ""no""
        reason = ""No sexual or sexualized content detected.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_66|Fan Disservice|"Is the trope ""Fan Disservice"", which means ""Fan Disservice looks like regular garden variety Fanservice, except that the creators intentionally use the circumstances around it to make the 
scene outright creepy or disgusting."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Fan Disservice
    # Definition: Fan Disservice looks like regular garden variety Fanservice, except that the creators intentionally use the circumstances around it to make the scene outright creepy or disgusting.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential Fanservice that turns into Fan Disservice.
    # 2. Contextual Analysis: Since the essence of Fan Disservice lies in the setup that makes the scene creepy or disgusting, we need to look for elements that are inconspicuously out of place or intentionally disturbing.
    # 3. Detecting Disservice: This involves analyzing the context, character reactions, and the overall tone of the scene.
    # 4. Answer Selection: Use the select_answer API to determine the most probable answer based on the analyzed data, considering the subtlety and intention behind making the scene disturbing or creepy.
    
    video_segment = VideoSegment(video, annotation)
    # Create an info dictionary to hold detected elements that might contribute to Fan Disservice
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Assuming functions exist for detecting Fanservice that turns creepy or disgusting
        fanservice_query = frame.simple_query(""Is there Fanservice in this scene?"", to_yesno=True)
        if ""yes"" in fanservice_query.lower():
            disservice_context = frame.simple_query(""What makes this Fanservice creepy or disgusting?"")
            info[f""Fanservice turned Fan Disservice at frame {i}""] = disservice_context
    
    # Since Fan Disservice is about the negative twist on Fanservice, we need to balance detection with the likelihood of an actual disturbing element being present.
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_67|Brick Joke|"Is the trope ""Brick Joke"", which means ""When two seemingly unrelated jokes work together to create a comedic effect."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Brick Joke
    # Definition: A narrative technique where a joke is set up early in the story and the punchline is delivered much later, often unexpectedly, linking back to the initial setup.
    # Thought Process:
    # 1. Frame Selection: Analyze frames throughout the video to identify potential setups and punchlines.
    # 2. Joke Detection: Identify elements or dialogues early in the video that could serve as a setup for a joke.
    # 3. Punchline Identification: Look for a punchline towards the end of the video that relates back to the initial setup.
    # 4. Answer Selection: Determine if the identified setup and punchline form a coherent Brick Joke as per the query.

    video_segment = VideoSegment(video, annotation)
    info = {}
    setups = {}
    punchlines = {}

    # Analyze each frame for potential joke setups
    for i, frame in enumerate(video_segment.frame_iterator()):
        joke_setup_query = ""Is there a joke setup in this scene? Describe it.""
        setup_description = frame.simple_query(joke_setup_query)
        if setup_description != ""No"":
            setups[i] = setup_description

    # Analyze each frame for potential punchlines that could link back to setups
    for i, frame in enumerate(video_segment.frame_iterator()):
        joke_punchline_query = ""Is there a punchline in this scene? Describe it.""
        punchline_description = frame.simple_query(joke_punchline_query)
        if punchline_description != ""No"":
            punchlines[i] = punchline_description

    # Check if any punchline relates back to an earlier setup
    for punchline_frame, punchline in punchlines.items():
        for setup_frame, setup in setups.items():
            if punchline_frame > setup_frame:  # Ensure punchline comes after the setup
                # Simulate a function that checks if the punchline relates to the setup
                related = frame.llm_query(f""Does the punchline '{punchline}' relate to the setup '{setup}'?"", to_yesno=True)
                if ""yes"" in related.lower():
                    info[f""Setup at frame {setup_frame}""] = setup
                    info[f""Punchline at frame {punchline_frame}""] = punchline
                    break

    # Determine if the Brick Joke trope is relevant based on collected setups and punchlines
    if info:
        answer = ""yes""
        reason = ""There are setups and corresponding punchlines that form a Brick Joke.""
    else:
        answer = ""no""
        reason = ""No setups and punchlines were found that correlate to form a Brick Joke.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_68|Hypocritical Humor|"Is the trope ""Hypocritical Humor"", which means ""A type of gag in which a character's actions or words contradict each other and this is Played for Laughs."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Hypocritical Humor
    # Definition: A type of gag in which a character's actions or words contradict each other and this is Played for Laughs.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to detect any character's actions or dialogues.
    # 2. Contradiction Detection: Identify any contradictions in what characters say versus what they do.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Hypocritical Humor"" is relevant.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Collect dialogues and actions from each character in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            character_dialogue = character.simple_query(""What is the character saying?"")
            character_action = character.simple_query(""What is the character doing?"")
            if character_id not in info:
                info[character_id] = []
            info[character_id].append({
                ""frame"": i,
                ""dialogue"": character_dialogue,
                ""action"": character_action
            })

    # Analyze the collected information for contradictions
    contradictions_found = False
    for character_id, actions in info.items():
        for action in actions:
            if action[""dialogue""].lower() in action[""action""].lower():
                contradictions_found = True
                break
        if contradictions_found:
            break

    # Determine if the trope is relevant based on the presence of contradictions
    answer = ""yes"" if contradictions_found else ""no""
    reason = ""Contradictions in actions and words were found."" if contradictions_found else ""No contradictions were detected.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_69|Does This Remind You of Anything?|"Is the trope ""Does This Remind You of Anything?"", which means ""Any situation which is made, sometimes for comic effect, sometimes for dramatic effect, to look like another situation."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Does This Remind You of Anything?
    # Definition: Any situation which is made, sometimes for comic effect, sometimes for dramatic effect, to look like another situation.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find situations that might be intentionally similar to well-known scenarios.
    # 2. Contextual Analysis: Look for visual or dialogue cues that mimic or reference other famous scenes or real-life events.
    # 3. Answer Selection: Use the select_answer API to determine if the trope is relevant based on the collected information.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for any intentional references or mimicking
        reference_query = frame.simple_query(""Is this scene made to look like another well-known situation?"", to_yesno=True)
        if ""yes"" in reference_query.lower():
            # Get details about the reference
            detailed_reference = frame.simple_query(""What situation does this scene resemble?"")
            info[f""Reference in frame {i}""] = detailed_reference

    # After collecting information, decide if the trope is relevant
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_70|Black Comedy|"Is the trope ""Black Comedy"", which means ""A sub-genre of comedy and satire where topics and events that are usually treated seriously are treated in a satirical manner, while still being 
portrayed as the negative events that they are."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Black Comedy
    # Definition: A sub-genre of comedy and satire where topics and events that are usually treated seriously are treated in a satirical manner, while still being portrayed as the negative events that they are.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential elements of black comedy, focusing on the juxtaposition of serious topics with humorous elements.
    # 2. Contextual Analysis: Since black comedy involves treating serious subjects humorously, detect scenes where serious topics are discussed or depicted alongside or within humorous contexts.
    # 3. Answer Selection: Use the select_answer API to determine the most probable answer based on the analyzed data, considering the presence of humor in serious contexts.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Detect serious topics being discussed or depicted
        serious_topic_query = frame.simple_query(""Is there a serious topic being discussed or depicted?"", to_yesno=True)
        # Detect humor or satire in the context of the serious topic
        humor_in_context_query = frame.simple_query(""Is there humor or satire present in the context of the serious topic?"", to_yesno=True)

        if ""yes"" in serious_topic_query.lower() and ""yes"" in humor_in_context_query.lower():
            # Collect information about the serious topic and the humor present
            serious_topic_description = frame.simple_query(""What is the serious topic?"")
            humor_description = frame.simple_query(""Describe the humor or satire present."")
            info[f""Serious topic in frame {i}""] = serious_topic_description
            info[f""Humor in frame {i}""] = humor_description

    # Answer the query
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_71|Irony|"Is the trope ""Irony"", which means ""The intended meaning is an inversion of the plain meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Irony
    # Definition: The intended meaning is an inversion of the plain meaning.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where actions or dialogues might have an ironic twist.
    # 2. Contextual Analysis: Look for discrepancies between what is said and what is meant, or between expectations and outcomes.
    # 3. Answer Selection: Use the select_answer API to determine if the irony trope is present based on the collected information.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for any ironic situations in the frame
        irony_query = frame.simple_query(""Is there any irony in this scene?"", to_yesno=True)
        if ""yes"" in irony_query.lower():
            # If irony is detected, gather more details
            detailed_description = frame.simple_query(""Describe the ironic situation."")
            info[f""Irony in frame {i}""] = detailed_description

    # After collecting information, use it to determine the presence of the irony trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_72|Exact Words|"Is the trope ""Exact Words"", which means ""When the exact wording of a rule, promise, prophecy, etc. matters more than the spirit of the wording, it's an Exact Words situation."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Exact Words
    # Definition: When the exact wording of a rule, promise, prophecy, etc. matters more than the spirit of the wording, it's an Exact Words situation.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for scenes where characters are discussing or referring to rules, promises, prophecies, etc.
    # 2. Text Analysis: Focus on the dialogue to detect if the exact wording is crucial or leads to a significant outcome or twist.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Exact Words"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for dialogue that might involve rules, promises, or prophecies
        dialogue = frame.simple_query(""What is being said in this scene?"")
        # Check if the dialogue involves a discussion about rules or promises
        involves_exact_words = frame.llm_query(f""Does the dialogue '{dialogue}' involve a situation where exact wording is crucial?"", to_yesno=True)

        if 'yes' in involves_exact_words.lower():
            # Collect the specific dialogue and the context
            exact_words_context = frame.simple_query(""Describe the context of the dialogue where exact wording is crucial."")
            info[f""Frame {i}""] = {
                ""Dialogue"": dialogue,
                ""Context"": exact_words_context
            }

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_73|Stealth Pun|"Is the trope ""Stealth Pun"", which means ""The writers put in a joke (almost always a pun), but never make or put in a Punch Line or explicit statement, hiding it in the set up of the joke. "", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Stealth Pun
    # Definition: A joke, typically a pun, is included by the writers but is not highlighted with a punchline or explicit statement. It's hidden within the setup of the joke, requiring the audience to notice and interpret it themselves.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential visual or audio cues that might indicate a hidden joke or pun. This requires understanding both the context and the elements present in the scene.
    # 2. Contextual Analysis: Since the essence of a Stealth Pun lies in the setup and requires audience interpretation, we need to look for elements that are inconspicuously out of place or cleverly integrated into the context but might not be immediately obvious.
    # 3. Detecting Puns: This involves analyzing the text or dialogue for play on words, and visual elements for any visual puns or jokes that rely on the visual context but are not explicitly acknowledged in the video.
    # 4. Answer Selection: Use the select_answer API to determine the most probable answer based on the analyzed data, considering the subtlety and clever integration of puns within the video content.
    video_segment = VideoSegment(video, annotation)
    # Create an info dictionary to hold detected elements that might contribute to a Stealth Pun
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Assuming functions exist for detecting puns in dialogue or visual elements
        has_pun_in_dialogue = frame.simple_query(""Are there any puns in the dialogue?"", to_yesno=True)
        has_visual_pun = frame.simple_query(""Are there any visual puns?"", to_yesno=True)
        # If either dialogue or visual analysis suggests a pun, collect this information
        if ""yes"" in has_pun_in_dialogue.lower() or ""yes"" in has_visual_pun.lower():
            dialogue_analysis = frame.simple_query(""What pun is in the dialogue?"")
            visual_pun_analysis = frame.simple_query(""What visual pun is in the frame?"")
            info[f""Pun in dialogue at frame {i}""] = dialogue_analysis
            info[f""Visual pun at frame {i}""] = visual_pun_analysis
    # Since Stealth Puns are about subtlety and not explicitly pointing out the joke, we need to balance detection with the likelihood of an actual pun being present without explicit acknowledgment.
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_74|Bittersweet Ending|"Is the trope ""Bittersweet Ending"", which means ""When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some 
irrevocable loss has happened during the course of the events, and nothing will ever be the same again."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Bittersweet Ending
    # Definition: When victory came at a harsh price, when, for whatever reason, the heroes cannot fully enjoy the reward of their actions, when some irrevocable loss has happened during the course of the events, and nothing will ever be the same again.
    # Thought Process:
    # 1. Frame Selection: Analyze the final part of the video to assess the ending.
    # 2. Emotional and Contextual Analysis: Look for visual cues of victory mixed with loss or sadness.
    # 3. Answer Selection: Use the collected information to determine if the ""Bittersweet Ending"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)

    # Create a dictionary to store information
    info = {
        ""emotional_cues"": {},
        ""contextual_cues"": {}
    }

    for i, frame in enumerate(ending_segment.frame_iterator()):
        # Detect visual cues of victory, loss, or sadness
        victory_query = frame.simple_query(""Is there a sense of victory?"", to_yesno=True)
        loss_query = frame.simple_query(""Is there a sense of loss or sadness?"", to_yesno=True)

        if ""yes"" in victory_query.lower() and ""yes"" in loss_query.lower():
            # Caption the frame
            caption = frame.simple_query(""What is happening in this scene?"")
            info[""emotional_cues""][f""frame {ending_segment.start + i}""] = {
                ""victory"": victory_query,
                ""loss"": loss_query,
                ""caption"": caption
            }

    # Answer the query
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_75|Karma Houdini|"Is the trope ""Karma Houdini"", which means ""The character has done a number of things that deserve a karmic comeuppance, most importantly things that caused harm to the innocent. But 
when the time comes for the hammer to fall, that's not what happens. At least, not on them. They don\t get what they deserve."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Karma Houdini
    # Definition: A character who avoids any significant consequences despite causing harm to the innocent.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to gather actions and consequences related to each character.
    # 2. Character Analysis: Identify actions of each character and check if they face any consequences.
    # 3. Answer Selection: Determine if there is a character who fits the trope of ""Karma Houdini"".

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {},
        ""character_consequences"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query about the actions of the person
            person_action = frame.simple_query(""What's he/she doing?"")
            # Query about the consequences faced by the person
            person_consequence = frame.simple_query(""What consequences is he/she facing?"")

            if person_id not in info[""character_actions""]:
                info[""character_actions""][person_id] = []
            if person_id not in info[""character_consequences""]:
                info[""character_consequences""][person_id] = []

            info[""character_actions""][person_id].append(person_action)
            info[""character_consequences""][person_id].append(person_consequence)

    # After collecting information, use it to determine if there is a Karma Houdini
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_76|Downer Ending|"Is the trope ""Downer Ending"", which means ""A finale to a movie that ends things in a way that varies from sad to tragic."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Downer Ending
    # Definition: A finale to a movie that ends things in a way that varies from sad to tragic.
    # Thought Process:
    # 1. Frame Selection: Focus on the last segment of the video as it pertains to the ending.
    # 2. Emotional and Contextual Analysis: Analyze the last frames for visual cues of sadness, tragedy, or loss.
    # 3. Answer Selection: Use the collected information to determine if the ending fits the ""Downer Ending"" trope.

    video_segment = VideoSegment(video)
    # Assuming the last 10% of the video is a reasonable segment to analyze for the ending
    ending_segment_start = int(video_segment.num_frames * 0.9)
    ending_segment = video_segment.trim(start=ending_segment_start)

    # Initialize info dictionary to store data collected during analysis
    info = {
        ""emotional_cues"": [],
        ""contextual_cues"": []
    }

    # Analyze frames in the ending segment
    for frame in ending_segment.frame_iterator():
        # Query for sadness or tragic elements
        sadness_query = frame.simple_query(""Is there sadness or mourning?"", to_yesno=True)
        tragedy_query = frame.simple_query(""Is there visible tragedy or destruction?"", to_yesno=True)

        # Collect data based on queries
        if ""yes"" in sadness_query.lower():
            sadness_detail = frame.simple_query(""Describe the sadness or mourning."")
            info[""emotional_cues""].append(sadness_detail)
        if ""yes"" in tragedy_query.lower():
            tragedy_detail = frame.simple_query(""Describe the tragedy or destruction."")
            info[""contextual_cues""].append(tragedy_detail)

    # Determine if the collected cues match the trope ""Downer Ending""
    if info[""emotional_cues""] or info[""contextual_cues""]:
        answer = ""yes""
        reason = ""The ending segment contains elements of sadness, tragedy, or loss.""
    else:
        answer = ""no""
        reason = ""The ending segment does not contain significant elements of sadness, tragedy, or loss.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_77|Laser-Guided Karma|"Is the trope ""Laser-Guided Karma"", which means ""If you mistreat the people and things around you, karma will strike you down."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Laser-Guided Karma
    # Definition: A narrative trope where if someone mistreats others, they will face immediate or eventual retribution in a manner that fits their misdeeds.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to observe any actions of mistreatment and subsequent retribution.
    # 2. Event Observation: Identify characters and their actions, especially focusing on negative actions and their consequences.
    # 3. Answer Selection: Use the collected information to determine if the trope of ""Laser-Guided Karma"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""actions"": {},
        ""consequences"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify all characters in the frame
        for person in frame.find(""person""):
            person_id = video_segment.face_identify(person)
            if person_id is None:
                continue
            # Query the action of the person
            action_description = frame.simple_query(""What is the person doing?"")
            # Check if the action is negative or harmful
            is_negative_action = frame.llm_query(f""Is the action '{action_description}' negative or harmful?"", to_yesno=True)
            if 'yes' in is_negative_action.lower():
                info[""actions""][person_id] = action_description
                # Check for immediate or eventual consequences in subsequent frames
                for j in range(i+1, min(i+10, video_segment.num_frames)):  # Check the next few frames for consequences
                    subsequent_frame = video_segment.frame_from_index(j)
                    consequence_description = subsequent_frame.simple_query(f""What happens to the person who did '{action_description}'?"")
                    if consequence_description:
                        info[""consequences""][person_id] = consequence_description
                        break

    # After collecting information, use it to determine the presence of the trope
    if info[""consequences""]:
        answer = ""yes""
        reason = ""Characters who performed negative actions faced immediate or eventual consequences, aligning with the trope of Laser-Guided Karma.""
    else:
        answer = ""no""
        reason = ""There were no clear consequences for negative actions observed in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_78|Earn Your Happy Ending|"Is the trope ""Earn Your Happy Ending"", which means ""A cast of characters in a story go through a lot more hardship, anguish and grief than is really necessary. In the end, however, you see them get 
their happily-ever-after."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Earn Your Happy Ending
    # Definition: A cast of characters in a story go through a lot more hardship, anguish, and grief than is really necessary. In the end, however, they achieve their happily-ever-after.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to understand the overall narrative arc.
    # 2. Character Analysis: Track the hardships and challenges faced by key characters throughout the video.
    # 3. Emotional and Contextual Analysis: Assess the emotional tone in the concluding segments of the video to determine if it aligns with a ""happily-ever-after"" ending.
    # 4. Answer Selection: Use the collected data to determine if the trope ""Earn Your Happy Ending"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_challenges"": {},
        ""ending_emotion"": """"
    }

    # Analyzing the entire video for character challenges and hardships
    for i, frame in enumerate(video_segment.frame_iterator()):
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query about the hardships or challenges faced by the character in this frame
            challenge_query = frame.simple_query(""What challenges or hardships is this character facing?"")
            if character_id not in info[""character_challenges""]:
                info[""character_challenges""][character_id] = []
            info[""character_challenges""][character_id].append(challenge_query)

    # Analyzing the emotional tone of the ending
    ending_frame = video_segment.frame_from_index(video_segment.num_frames - 1)
    ending_emotion_query = ending_frame.simple_query(""What is the emotional tone in this scene?"")
    info[""ending_emotion""] = ending_emotion_query

    # Determine if the ending is happy and if the characters have gone through significant hardships
    hardships_present = any(info[""character_challenges""].values())
    happy_ending = ""happy"" in info[""ending_emotion""].lower()

    if hardships_present and happy_ending:
        answer = ""yes""
        reason = ""The characters faced significant hardships but achieved a happy ending.""
    else:
        answer = ""no""
        reason = ""The narrative does not align with the 'Earn Your Happy Ending' trope.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_79|Karmic Death|"Is the trope ""Karmic Death"", which means ""When the villain dies in a manner that is completely their own fault. Or, at least, obviously not the hero's."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Karmic Death
    # Definition: When the villain dies in a manner that is completely their own fault, or at least, obviously not the hero's.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to find the death scene of a character identified as a villain.
    # 2. Contextual Analysis: Determine if the death was due to the villain's own actions or decisions.
    # 3. Answer Selection: Use the collected information to decide if the ""Karmic Death"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    villain_death_found = False
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for the presence of a death scene
        if frame.exists(""death scene""):
            # Identify if the deceased is a villain
            deceased = frame.find(""villain"")
            if deceased:
                # Check if the death was caused by the villain's own actions
                cause_of_death = frame.simple_query(""What caused the death?"")
                villain_actions = frame.simple_query(""What was the villain doing before death?"")
                info[f""Frame {i}""] = {
                    ""Cause of Death"": cause_of_death,
                    ""Villain Actions"": villain_actions
                }
                # Determine if the death can be considered 'Karmic'
                if ""own actions"" in cause_of_death or ""mistake"" in cause_of_death:
                    villain_death_found = True

    if villain_death_found:
        answer = ""yes""
        reason = ""The villain died due to their own actions, fitting the 'Karmic Death' trope.""
    else:
        answer = ""no""
        reason = ""There was no clear evidence that the villain's death was due to their own actions.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_80|Nice Job Breaking It, Hero!|"Is the trope ""Nice Job Breaking It, Hero!"", which means ""The hero has accomplished their goal, but it turns out that by the very act of success, they've unwittingly made things worse."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Nice Job Breaking It, Hero!
    # Definition: The hero has accomplished their goal, but it turns out that by the very act of success, they've unwittingly made things worse.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to understand the narrative arc and identify key moments where the hero's actions lead to unintended consequences.
    # 2. Event Analysis: Focus on the climax or turning points where the hero's actions are pivotal.
    # 3. Answer Selection: Use the collected information to determine if the trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""key_events"": {},
        ""hero_actions"": {},
        ""consequences"": {}
    }

    # Analyze frames to capture the hero's actions and the resulting consequences
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify if there's a hero and their actions in the frame
        hero_query = frame.simple_query(""Is there a hero in the scene?"", to_yesno=True)
        if ""yes"" in hero_query.lower():
            action_description = frame.simple_query(""What action is the hero taking?"")
            consequence_description = frame.simple_query(""What are the consequences of the hero's action?"")

            # Store the hero's actions and the consequences
            info[""hero_actions""][f""Frame {i}""] = action_description
            info[""consequences""][f""Frame {i}""] = consequence_description

            # Check if the consequences are negative and unintended
            negative_consequence_query = frame.simple_query(""Are the consequences negative and unintended?"", to_yesno=True)
            if ""yes"" in negative_consequence_query.lower():
                info[""key_events""][f""Frame {i}""] = {
                    ""action"": action_description,
                    ""consequence"": consequence_description
                }

    # After collecting information, use it to determine the presence of the trope
    if info[""key_events""]:
        answer = ""yes""
        reason = ""The hero's actions led to unintended negative consequences, aligning with the 'Nice Job Breaking It, Hero!' trope.""
    else:
        answer = ""no""
        reason = ""There were no significant events where the hero's actions led to worse outcomes.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_81|My God, What Have I Done?|"Is the trope ""My God, What Have I Done?"", which means ""Well-intentioned but misguided character (very likely a Tragic Hero, a Tragic Villain or Anti-Villain) comes to realize that his actions have
 caused incredible damage, physical pain, emotional pain, or even loss of life."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: My God, What Have I Done?
    # Definition: A well-intentioned but misguided character (very likely a Tragic Hero, a Tragic Villain, or Anti-Villain) comes to realize that their actions have caused incredible damage, physical pain, emotional pain, or even loss of life.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find moments of realization or regret expressed by characters.
    # 2. Character Analysis: Identify key characters and analyze their expressions and actions for signs of regret or realization of the consequences of their actions.
    # 3. Contextual Analysis: Understand the context around these moments to confirm if the regret is due to the character's own actions.
    # 4. Answer Selection: Use the collected information to determine if the trope ""My God, What Have I Done?"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    regretful_moments = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Identify characters in the frame
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue

            # Query about the character's actions and emotions
            character_action = frame.simple_query(""What's he/she doing?"")
            character_emotion = frame.simple_query(""What's his/her emotion?"")

            # Check for expressions of regret or realization
            if ""regret"" in character_emotion.lower() or ""realization"" in character_emotion.lower():
                context_query = ""What led to this emotion?""
                context_response = frame.simple_query(context_query)
                regretful_moments.append({
                    ""frame_index"": i,
                    ""character_id"": character_id,
                    ""action"": character_action,
                    ""emotion"": character_emotion,
                    ""context"": context_response
                })

    # Store information about detected moments of regret
    info[""regretful_moments""] = regretful_moments

    # Determine if the trope is applicable based on the collected moments
    if regretful_moments:
        answer = ""yes""
        reason = ""There are characters showing realization or regret for their actions which caused harm.""
    else:
        answer = ""no""
        reason = ""No significant moments of realization or regret related to the character's own actions were found.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_82|What the Hell, Hero?|"Is the trope ""What the Hell, Hero?"", which means ""When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: What the Hell, Hero?
    # Definition: When characters In-Universe call out one of the heroes for doing something clearly unheroic, if not outright heinous.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where a character is being called out by others.
    # 2. Contextual Analysis: Look for dialogue or actions that indicate a hero is being criticized for unheroic behavior.
    # 3. Answer Selection: Use the collected information to determine if the trope ""What the Hell, Hero?"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for dialogue indicating criticism of a hero
        criticism_query = ""Is there any dialogue criticizing a hero for their actions?""
        has_criticism = frame.simple_query(criticism_query, to_yesno=True)
        if ""yes"" in has_criticism.lower():
            # Get details about the criticism
            criticism_details = frame.simple_query(""What is the criticism about and who is involved?"")
            info[f""Criticism in frame {i}""] = criticism_details

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_83|Hope Spot|"Is the trope ""Hope Spot"", which means ""The Protagonist is about to face utter defeat. Suddenly, he finds a glimmer of hope what have you only to be crushed cruelly by the bad guys 
returning in force."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Hope Spot
    # Definition: The protagonist is about to face utter defeat. Suddenly, they find a glimmer of hope, only to be cruelly crushed by the antagonists returning in force.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to find moments where the protagonist finds hope followed by a crushing event.
    # 2. Emotional and Contextual Analysis: Look for visual cues of hope such as expressions of relief or joy, followed by expressions of despair or defeat.
    # 3. Answer Selection: Use the collected information to determine if the ""Hope Spot"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""hope_moments"": [],
        ""crushing_moments"": []
    }

    # Iterate through the video frames to detect the sequence of hope followed by despair
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for hope and despair events
        hope_query = frame.simple_query(""Is there a moment of hope?"", to_yesno=True)
        despair_query = frame.simple_query(""Is there a moment of despair?"", to_yesno=True)

        # Collect information about hope and despair moments
        if ""yes"" in hope_query.lower():
            hope_description = frame.simple_query(""Describe the moment of hope."")
            info[""hope_moments""].append(f""Frame {i}: {hope_description}"")

        if ""yes"" in despair_query.lower():
            despair_description = frame.simple_query(""Describe the moment of despair."")
            info[""crushing_moments""].append(f""Frame {i}: {despair_description}"")

    # Determine if the sequence of hope followed by despair fits the trope
    if info[""hope_moments""] and info[""crushing_moments""]:
        answer, reason = video_segment.select_answer(info, query, possible_answers)
    else:
        answer = ""no""
        reason = ""No clear sequence of hope followed by despair was detected.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_84|Heel Face Turn|"Is the trope ""Heel Face Turn"", which means ""When a bad guy turns good."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Heel Face Turn
    # Definition: When a bad guy turns good.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to observe character development and changes in alignment from negative to positive.
    # 2. Character Analysis: Identify key characters and track their actions and motivations throughout the video.
    # 3. Answer Selection: Use the collected data to determine if a ""Heel Face Turn"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_actions"": {},
        ""character_changes"": {}
    }

    # Analyze each frame for character actions and changes
    for i, frame in enumerate(video_segment.frame_iterator()):
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Get character actions and motivations
            character_action = frame.simple_query(""What's he/she doing?"")
            character_motivation = frame.simple_query(""What's his/her motivation?"")

            # Store character actions and motivations
            if character_id not in info[""character_actions""]:
                info[""character_actions""][character_id] = []
            info[""character_actions""][character_id].append(character_action)

            # Detect significant changes in behavior or motivation
            if ""change"" in character_motivation.lower():
                info[""character_changes""][character_id] = character_motivation

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_85|Took a Level in Badass|"Is the trope ""Took a Level in Badass"", which means ""A charcter who is transformed into someone stronger and tougher that the viewer almost can't recognize him."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Took a Level in Badass
    # Definition: A character who is transformed into someone stronger and tougher that the viewer almost can't recognize him.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find significant changes in a character's appearance or abilities.
    # 2. Character Analysis: Identify each character and collect their actions or character traits at different points in the video.
    # 3. Answer Selection: Using the collected data, decide whether the ""Took a Level in Badass"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""character_changes"": {}
    }

    for i, frame in enumerate(video_segment.frame_iterator()):
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Get description of character's appearance and actions
            character_description = character.simple_query(""Describe the character's appearance and actions."")
            if character_id not in info[""character_changes""]:
                info[""character_changes""][character_id] = []
            info[""character_changes""][character_id].append(character_description)

    # After collecting information, use it to determine the presence of the trope
    transformed_characters = []
    for character_id, descriptions in info[""character_changes""].items():
        if len(descriptions) > 1 and descriptions[0] != descriptions[-1]:
            transformed_characters.append(character_id)

    if transformed_characters:
        answer = ""yes""
        reason = f""The following characters took a level in badass: {', '.join(transformed_characters)}""
    else:
        answer = ""no""
        reason = ""No significant transformations observed in characters.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_86|Chekhov's Gun|"Is the trope ""Chekhov's Gun"", which means ""An insignificant object that later turns out to be important."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Chekhov's Gun
    # Definition: An insignificant object that later turns out to be important.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify any objects that might initially appear insignificant.
    # 2. Object Tracking: Track these objects across the frames to see if they gain significance later in the video.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Chekhov's Gun"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    identified_objects = {}

    # Analyze each frame for objects
    for i, frame in enumerate(video_segment.frame_iterator()):
        objects_in_frame = frame.find(""object"")
        for obj in objects_in_frame:
            object_description = obj.simple_query(""What is this object?"")
            if object_description not in identified_objects:
                identified_objects[object_description] = {
                    ""first_appearance"": i,
                    ""last_appearance"": i,
                    ""significance"": obj.simple_query(""Is this object significant?"", to_yesno=True)
                }
            else:
                identified_objects[object_description][""last_appearance""] = i
                if ""no"" in identified_objects[object_description][""significance""].lower():
                    current_significance = obj.simple_query(""Is this object significant?"", to_yesno=True)
                    if ""yes"" in current_significance.lower():
                        identified_objects[object_description][""significance""] = ""yes""

    # Determine if any object fits the trope ""Chekhov's Gun""
    for obj_desc, details in identified_objects.items():
        if ""no"" in details[""significance""].lower() and (details[""last_appearance""] - details[""first_appearance""] > video_segment.num_frames * 0.5):
            info[obj_desc] = ""Object initially deemed insignificant but later became significant.""

    # Use the collected information to answer the query
    if any(""yes"" in details[""significance""].lower() for details in identified_objects.values()):
        answer, reason = ""yes"", ""There is at least one object that was initially insignificant but later became important.""
    else:
        answer, reason = ""no"", ""No objects were found that fit the criteria of 'Chekhov's Gun'.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_87|Foreshadowing|"Is the trope ""Foreshadowing"", which means ""A clue or allusion embedded in the narrative that predicts some later event or revelation."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Foreshadowing
    # Definition: A clue or allusion embedded in the narrative that predicts some later event or revelation.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for potential clues or allusions that might predict future events.
    # 2. Contextual Analysis: Look for elements that are subtly introduced which might have a significant impact later in the narrative.
    # 3. Answer Selection: Use the select_answer API to determine if the trope ""Foreshadowing"" is relevant based on the collected information.

    video_segment = VideoSegment(video, annotation)
    info = {}
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query each frame for potential foreshadowing elements
        foreshadowing_query = frame.simple_query(""Are there any elements or dialogues that hint at future events?"", to_yesno=True)
        if ""yes"" in foreshadowing_query.lower():
            # If foreshadowing elements are found, collect more detailed information
            detailed_description = frame.simple_query(""Describe the elements or dialogues that hint at future events."")
            info[f""Frame {i}""] = detailed_description

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_88|Chekhov's Skill|"Is the trope ""Chekhov's Skill"", which means ""Training in any kind of skill, ability, or knowledge that will likely later come in handy."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Chekhov's Skill
    # Definition: Training in any kind of skill, ability, or knowledge that will likely later come in handy.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances of characters learning or demonstrating a skill.
    # 2. Contextual Analysis: Determine if the skills shown are relevant to the plot or are likely to be used later in the story.
    # 3. Answer Selection: Use the select_answer API to choose the most likely answer based on the collected information.

    video_segment = VideoSegment(video, annotation)
    info = {}
    skill_events = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query each frame to see if a character is learning or using a skill
        learning_query = frame.simple_query(""Is someone learning or demonstrating a skill?"", to_yesno=True)
        if ""yes"" in learning_query.lower():
            # Describe the skill and context
            skill_description = frame.simple_query(""What skill is being learned or demonstrated and how is it relevant to the story?"")
            skill_events.append(skill_description)
            info[f""Skill event at frame {i}""] = skill_description

    # After collecting information, determine if the skill is likely to be used later
    if skill_events:
        # Construct a query to check if the skills are plot-relevant
        relevance_query = ""Are the skills demonstrated likely to be used later in the story?""
        relevance = video_segment.llm_query(relevance_query, to_yesno=True)
        info[""Relevance of skills to plot""] = relevance
        answer, reason = video_segment.select_answer(info, query, possible_answers)
    else:
        answer, reason = ""no"", ""No skills were demonstrated or learned that are relevant to the plot.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_89|Chekhov's Gunman|"Is the trope ""Chekhov's Gunman"", which means ""Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Chekhov's Gunman
    # Definition: Any character who is innocuously and unimportantly introduced to the viewer, but who later proves to be important by the end of the episode.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to identify all characters and their roles.
    # 2. Character Development: Track the development and importance of each character from their introduction to the end.
    # 3. Answer Selection: Determine if there is a character that fits the trope of ""Chekhov's Gunman"".

    video_segment = VideoSegment(video, annotation)
    info = {}
    character_importance = {}

    # Iterate through each frame to identify and track characters
    for i, frame in enumerate(video_segment.frame_iterator()):
        for character in frame.find(""person""):
            character_id = video_segment.face_identify(character)
            if character_id is None:
                continue
            # Query the role or action of the character in the frame
            character_action = frame.simple_query(""What's he/she doing?"")
            character_role = frame.simple_query(""What role does this person play in the scene?"")

            # Initialize or update character tracking
            if character_id not in character_importance:
                character_importance[character_id] = {
                    'introduction_frame': i,
                    'actions': [],
                    'roles': [],
                    'last_seen_frame': i
                }
            character_importance[character_id]['actions'].append(character_action)
            character_importance[character_id]['roles'].append(character_role)
            character_importance[character_id]['last_seen_frame'] = i

    # Analyze character data to determine if any fit the trope
    for character_id, details in character_importance.items():
        # Check if the character was initially unimportant but became important
        initial_role = details['roles'][0]
        final_role = details['roles'][-1]
        if initial_role.lower() in ['background', 'extra', 'minor'] and final_role.lower() not in ['background', 'extra', 'minor']:
            info[character_id] = {
                'introduction_frame': details['introduction_frame'],
                'last_seen_frame': details['last_seen_frame'],
                'initial_role': initial_role,
                'final_role': final_role
            }

    # Determine the answer based on the analysis
    if info:
        answer = 'yes'
        reason = f""Characters transitioned from minor to major roles: {info}""
    else:
        answer = 'no'
        reason = ""No character fits the 'Chekhov's Gunman' trope.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_90|Red Herring|"Is the trope ""Red Herring"", which means ""A clue that leads in the wrong direction."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Red Herring
    # Definition: A clue that leads in the wrong direction.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find potential misleading clues or elements.
    # 2. Clue Analysis: Identify and analyze elements or dialogues that might be considered as misleading.
    # 3. Answer Selection: Use the collected information to determine if the ""Red Herring"" trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    misleading_elements = []

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for potential misleading elements in the frame
        misleading_query = frame.simple_query(""Are there any misleading elements or clues in this scene?"", to_yesno=True)
        if ""yes"" in misleading_query.lower():
            # Detail about misleading elements
            element_description = frame.simple_query(""Describe the misleading element or clue."")
            misleading_elements.append(element_description)
            info[f""Frame {i} with misleading element""] = element_description

    # If there are any misleading elements collected, consider the trope might be relevant
    if misleading_elements:
        answer = ""yes""
        reason = ""Misleading elements or clues were identified in the video.""
    else:
        answer = ""no""
        reason = ""No misleading elements or clues were found in the video.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_91|Ironic Echo|"Is the trope ""Ironic Echo"", which means ""When a character repeats a comment they received in a different situation, giving it a flipped or surprising new meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Ironic Echo
    # Definition: When a character repeats a comment they received in a different situation, giving it a flipped or surprising new meaning.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame to find instances where characters are speaking or interacting.
    # 2. Dialogue Analysis: Identify and compare dialogues across different frames to detect repeated phrases with altered contexts or meanings.
    # 3. Answer Selection: Use the collected information to determine if the ""Ironic Echo"" trope is present.

    video_segment = VideoSegment(video, annotation)
    info = {}
    previous_dialogues = {}

    for i, frame in enumerate(video_segment.frame_iterator()):
        # Query for dialogue in the current frame
        dialogue = frame.simple_query(""What is being said?"")
        if dialogue:
            # Check if the dialogue has been spoken before with a different context
            if dialogue in previous_dialogues:
                previous_frame, previous_context = previous_dialogues[dialogue]
                current_context = frame.simple_query(""What is the context of this dialogue?"")
                if current_context != previous_context:
                    info[f""Echoed dialogue in frame {i}""] = {
                        ""dialogue"": dialogue,
                        ""first_occurrence_frame"": previous_frame,
                        ""first_occurrence_context"": previous_context,
                        ""current_frame"": i,
                        ""current_context"": current_context
                    }
            else:
                # Store the dialogue with its context and frame number for future comparison
                context = frame.simple_query(""What is the context of this dialogue?"")
                previous_dialogues[dialogue] = (i, context)

    # Determine if the trope is present based on collected dialogues
    if info:
        answer = ""yes""
        reason = ""Ironic Echo is identified where dialogues are repeated in different contexts.""
    else:
        answer = ""no""
        reason = ""No Ironic Echo found as no dialogues are repeated in different contexts.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_92|Hoist by His Own Petard|"Is the trope ""Hoist by His Own Petard"", which means ""The villain's own weapon or malicious plan is the cause of their downfall and/or death."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Hoist by His Own Petard
    # Definition: The villain's own weapon or malicious plan is the cause of their downfall and/or death.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to find scenes involving the villain and their plans or weapons.
    # 2. Event Observation: Identify key events where the villain uses or sets up a weapon or plan.
    # 3. Consequence Analysis: Determine if these actions directly lead to the villain's downfall or death.
    # 4. Answer Selection: Use the collected information to decide if the trope is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {
        ""villain_actions"": {},
        ""downfall_events"": {}
    }

    # Iterate through each frame to analyze the villain's actions and their consequences
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check for the presence of the villain and any significant actions or plans
        if frame.exists(""villain""):
            action_description = frame.simple_query(""What is the villain doing?"")
            # Record the villain's actions
            info[""villain_actions""][f""frame {i}""] = action_description

            # Check if the action involves setting up or using a weapon or plan
            if ""weapon"" in action_description or ""plan"" in action_description:
                # Determine the immediate consequences of these actions
                consequence = frame.simple_query(""What happens immediately after this action?"", to_yesno=True)
                if ""yes"" in consequence.lower():
                    # Describe the downfall or negative outcome for the villain
                    downfall_description = frame.simple_query(""Describe the downfall or negative outcome."")
                    info[""downfall_events""][f""frame {i}""] = downfall_description

    # After collecting information, use it to determine the presence of the trope
    answer, reason = video_segment.select_answer(info, query, possible_answers)
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_93|Meaningful Echo|"Is the trope ""Meaningful Echo"", which means ""It occurs when characters, in their usual way, say things to one another, and repeat it later on to give extra meaning."", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Meaningful Echo
    # Definition: It occurs when characters, in their usual way, say things to one another, and repeat it later on to give extra meaning.
    # Thought Process:
    # 1. Frame Selection: Analyze each frame for dialogues and identify repeated phrases.
    # 2. Contextual Analysis: Determine the context in which the phrases are repeated and if they gain additional meaning in the later context.
    # 3. Answer Selection: Use the collected information to determine if the trope ""Meaningful Echo"" is relevant to the movie.

    video_segment = VideoSegment(video, annotation)
    info = {}
    dialogues = {}

    # Iterate through each frame to collect dialogues
    for i, frame in enumerate(video_segment.frame_iterator()):
        dialogue = frame.simple_query(""What is being said?"")
        if dialogue not in dialogues:
            dialogues[dialogue] = [i]
        else:
            dialogues[dialogue].append(i)

    # Analyze the context of repeated dialogues
    for dialogue, frames in dialogues.items():
        if len(frames) > 1:
            first_occurrence = frames[0]
            last_occurrence = frames[-1]
            first_context = video_segment.frame_from_index(first_occurrence).simple_query(""What is the context of this dialogue?"")
            last_context = video_segment.frame_from_index(last_occurrence).simple_query(""What is the context of this dialogue?"")
            info[dialogue] = {
                ""first_occurrence"": first_occurrence,
                ""last_occurrence"": last_occurrence,
                ""first_context"": first_context,
                ""last_context"": last_context
            }

    # Determine if the repeated dialogue adds meaningful echo
    meaningful_echoes = []
    for dialogue, details in info.items():
        if details[""first_context""] != details[""last_context""]:
            meaningful_echoes.append(dialogue)

    # Select the answer based on the analysis
    answer = ""yes"" if meaningful_echoes else ""no""
    reason = ""Dialogues with changed contexts: "" + "", "".join(meaningful_echoes) if meaningful_echoes else ""No dialogues were repeated with additional meaning.""
    
    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
NO EXECUTION|yes|tt0120586_94|Freudian Excuse|"Is the trope ""Freudian Excuse"", which means ""The villain had an abusive and particularly violent childhood (such as Abusive Parents, being bullied by peers, etc.), making them insane and warping their perception on the universe"", relevant to the movie?"|/project/mira/dataset/MovieNet/videos/tt0120586.mp4|['yes', 'no']|"```python
def execute_command(video, annotation, possible_answers, query):
    # Trope: Freudian Excuse
    # Definition: The villain had an abusive and particularly violent childhood (such as Abusive Parents, being bullied by peers, etc.), making them insane and warping their perception on the universe.
    # Thought Process:
    # 1. Frame Selection: Analyze the entire video to find any backstory or flashbacks that relate to the villain's childhood.
    # 2. Contextual Analysis: Look for scenes depicting the villain's past, focusing on interactions with parents or peers.
    # 3. Emotional and Contextual Cues: Detect any signs of abuse or violence in these interactions.
    # 4. Answer Selection: Use the collected information to determine if the trope ""Freudian Excuse"" is applicable.

    video_segment = VideoSegment(video, annotation)
    info = {}
    villain_id = None

    # Iterate through each frame to find relevant backstory or flashbacks
    for i, frame in enumerate(video_segment.frame_iterator()):
        # Check if the frame contains a flashback or backstory
        is_flashback = frame.simple_query(""Is this a flashback or backstory?"", to_yesno=True)
        if ""yes"" in is_flashback.lower():
            # Identify characters in the flashback
            for character in frame.find(""person""):
                character_id = video_segment.face_identify(character)
                if character_id is None:
                    continue
                # Determine if the character is the villain
                is_villain = frame.simple_query(f""Is the person identified as {character_id} the villain?"", to_yesno=True)
                if ""yes"" in is_villain.lower():
                    villain_id = character_id
                    # Collect information about interactions with parents or peers
                    interaction_description = frame.simple_query(""Describe the interaction with parents or peers."")
                    info[f""Interaction in frame {i}""] = interaction_description
                    # Detect signs of abuse or violence
                    signs_of_abuse = frame.simple_query(""Are there signs of abuse or violence in the interaction?"", to_yesno=True)
                    info[f""Signs of abuse in frame {i}""] = signs_of_abuse

    # After collecting information, use it to determine the presence of the trope
    if villain_id and any(""yes"" in info[key].lower() for key in info if ""Signs of abuse"" in key):
        answer = ""yes""
        reason = f""Villain {villain_id} had an abusive childhood as depicted in the flashbacks.""
    else:
        answer = ""no""
        reason = ""No clear evidence of an abusive childhood for the villain was found.""

    return answer, reason, info
```"|{}|NO EXECUTION|NO EXECUTION|NO EXECUTION
